\documentclass[11pt,b5paper,oneside,lualatex]{ltjsarticle} % LuaLaTeXの場合
%\documentclass[11pt,a4paper,oneside,titlepage,lualatex]{ltjsreport} % 表紙付き, 章から始まる形式

%SumatraPDFの逆順検索でエラーが出た時は以下のコマンドラインをSumatraPDFの設定→オプションで入力する
%"C:\Program Files (x86)\TeXstudio\texstudio.exe" "%f" -line %l

\usepackage{luatexja} % ltjclasses, ltjsclasses を使うときはこの行不要
\usepackage[marginparwidth=0pt,margin=10truemm]{geometry} % 余白の設定
% スマホやタブレットでも読みやすいB5サイズの文書を書くときは, 1行目の\documentclassのオプションで「a4paper」を「b5paper」にして, 余白設定はmargin=10truemmにすると自分好み

% --------------------------------------------------------------------------
%		パッケージとコマンド
% --------------------------------------------------------------------------

\usepackage{mypackage} % よく使うパッケージ. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmypackage.styを読み込む
\usepackage{mycommand} % 自分で定義したコマンド. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmycommand.styを読み込む

\usetikzlibrary{knots}

%\usetikzlibrary{graphs,graphs.standard,graphdrawing} % TikZでグラフを描く
%\usegdlibrary{trees,force,layered} %graphdrawingの子ライブラリ

\DeclareMathOperator{\WRT}{WRT}
\DeclareMathOperator{\perm}{perm}
\DeclareMathOperator{\erf}{erf}
\renewcommand{\setminus}{\smallsetminus}

% --------------------------------------------------------------------------
%		ハイパーリンク
% --------------------------------------------------------------------------

%目次にもハイパーリンクが付く. プリアンブルのできるだけ後ろに書く. 
\usepackage[luatex, pdfencoding=auto,hypertexnames=false]{hyperref}
\hypersetup{% hyperrefオプションリスト
	colorlinks=true,
	linkcolor=DarkGoldenrod, % リンクの色
	citecolor=SlateBlue, % 引用文献の色
	urlcolor=violet, % URLの色
}

% --------------------------------------------------------------------------
%		定理環境と相互参照
% --------------------------------------------------------------------------

% 参照番号の設定
\numberwithin{equation}{section} % 式番号
\newtheorem{theoremcounter}{}[section] % 定理番号のオプションを選択. [section]を[chapter]にすれば章番号から始まり「定理 1.1.1」のようになる.
\newtheorem{exercisecounter}{}[] % 演習問題番号のオプションを選択.

% 自作スタイルファイル読み込み
\usepackage{mytheorem} % cleverefパッケージによる定理環境と相互参照. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmytheorem.styを読み込む. \usepackage{hyperref}の後に書く. 

%\usepackage{myprogram} % ハイライト付きソースコード. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmyprogram.styを読み込む

% --------------------------------------------------------------------------
\begin{document}
% --------------------------------------------------------------------------

\title{Zwegersの不定値テータ関数}
\author{村上友哉}
\date{\today}

\maketitle

%シンプルな目次
\tableofcontents

% --------------------------------------------------------------------------

\section{導入と主結果} \label{sec:intro}

% --------------------------------------------------------------------------



本稿の構成を述べる. 
\cref{sec:mock}ではZwegersの研究の動機となったRamanujanのモックテータ関数について説明する.
\cref{sec:indefinite_theta}では
\cref{sec:Zwegers_theta}では

本稿を通して以下の記号を用いる. 

\begin{symb}
	\begin{itemize}
		\item 複素数$ \tau $であって$ \Im(\tau) > 0 $なるもの.
		\item 絶対値が$ 1 $未満の複素数$ q := e^{2\pi\iu\tau} $.
	\end{itemize}
\end{symb}

% --------------------------------------------------------------------------

\section{Ramanujanの\ruby{擬}{モック}テータ関数と不定値テータ関数} \label{sec:mock}

% --------------------------------------------------------------------------

Zwegersによる不定値テータ関数の研究の動機にはRamanujanの\ruby{擬}{モック}テータ関数がある. 
そこで本節ではRamanujanの\ruby{擬}{モック}テータ関数の研究をかいつまんで紹介し, 不定値テータ関数とどのように関係するかを解説する. 

% --------------------------------------------------------------------------

\subsection{\ruby{擬}{モック}テータ関数からの研究の動機} \label{subsec:mock}

% --------------------------------------------------------------------------

Ramanujanがその最期にHardyへと宛てた手紙には, 彼が\textbf{\ruby{擬}{モック}テータ関数}と称する非常に奇妙な無限級数が記されていた. 
それがどのくらい奇妙なものかは実例を挙げれば一目瞭然である. 

\begin{dfn}[Ramanujanの位数$ 5 $の\ruby{擬}{モック}テータ関数]
	\[
	f_0(q) :=
%	\sum_{n=0}^{\infty} \frac{q^{n^2}}{(-q)_n}
%	=
	1 + \sum_{n=1}^{\infty} \frac{q^{n^2}}{(1+q)(1+q^2) \cdots (1+q^n)}.
	\]
\end{dfn}

%ただしここで$ (a)_n $はPochchammer記号で, 以下のように定義される. 
%
%\begin{dfn}[Pochhammer記号]
%	複素数$ a $と$ n \in \Z_{\ge 0} \cup \{ \infty \} $に対し
%	\[
%	(a)_n :=
%	\begin{cases}
%		1 & n=0, \\
%		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) & n \in \Z_{>0}, \\
%		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) \cdots & n = \infty.
%	\end{cases}
%	\]
%\end{dfn}

「今まで数学をやってきて, このような関数は見たことが無い」というのが私の率直な感想である. 
何しろ無限和の中に多項式の積が入り込んでいるのだ. 
このような関数を一体どのようにして研究できるというのだろうか？

だが投げ出す前に少し落ち着いて考えてみよう. 
「\ruby{擬}{モック}テータ関数」というRamanujanの命名は意味ありげである. 
このように名付けたからにはRamanujanはテータ関数に類似した性質を期待していたのだろう. 
しかしながら, 本来のテータ関数は正整数$ r $と正定値対称行列$ S \in \GL_r(\R) $に対して
\[
\theta_S (\tau) :=
\sum_{n \in \Z^r} q^{{}^t\!n S n/2}, \quad
q := e^{2\pi\iu\tau}
\]
と定義されるもので, Ramanujanの\ruby{擬}{モック}テータ関数とは似ても似つかない. 
果たして本当に類似した性質など期待できるだろうか？

だが「それでも何かありそうだ」と思わせるのがRamanujanである. 
もし仮に通常のテータ関数と\ruby{擬}{モック}テータ関数の間に類似した性質があるとすれば, それは何だろうか？

安直に思いつくのはテータ関数のモジュラー変換則である. 

\begin{prop}[テータ関数のモジュラー変換則, {\cite[命題2.5.1]{高瀬}}]
	\label{prop:theta_modular_trans}
	\[
%	\theta_S (\tau + 1) = \theta_S (\tau), \quad
	\theta_S \left( -\frac{1}{\tau} \right) =
	\sqrt{\det S} \sqrt{-\iu \tau}^r \theta_S (\tau).
	\]
\end{prop}

この性質は非常に重要である. 
例えば最も簡単な$ r = 1, S = 1 $の場合にこの性質を用いることでRiemannゼータ関数の関数等式を得ることができる. 
またこの性質はテータ関数がモジュラー形式をなすことを意味しており, モジュラー形式の理論を応用することで様々な数論的帰結を得ることが可能である. 

そこで\textbf{\ruby{擬}{モック}テータ関数に対してもモジュラー変換則が満たされること}を期待してみたくなる. 
だがそれはいくら何でも楽観的過ぎるだろうか？

状況証拠はRamanujanの手紙に既に記されていた. 
Ramanujanは
\begin{itemize}
	\item \ruby{擬}{モック}テータ関数たちが非自明な関係式を満たすこと
	\item \ruby{擬}{モック}テータ関数のFourier係数の漸近的性質
\end{itemize}
を発見していたが, これらは共にモジュラー形式が持つ性質である. 
この期待を単に楽観的と片付けるのは勿体無さそうだ. 

状況証拠は\ruby{擬}{モック}テータ関数の研究が進むにつれて更に集まり始めた. 
例えばWatson~\cite[pp. 78]{Watson}は位数$ 3 $の\ruby{擬}{モック}テータ関数に対してモジュラー変換則を記述することに成功している. 
それは通常のテータ関数のような単純な形ではなく誤差項を含んでおり, 非常に驚くべき式ではあるものの「確かに記述できるのは分かったけどこれで理解できたとは思えないなあ」と筆者には感じられる式である. 
Watsonの証明には拡張性に乏しく全ての\ruby{擬}{モック}テータ関数に適用することが難しいという問題もあった（彼の方法は\ruby{擬}{モック}テータ関数の「Appell--Lerch型和」と呼ばれる表示式に基づく巧妙なものである）. 

更にその後, AndrewsやHickersonが\ruby{擬}{モック}テータ関数の「Hecke型表示」を発見した. 
それは例えば次のような表示式である. 

\begin{thm}[Andrews~{\cite[Equation (1.4)]{Andrews_5_7}}]
	\[
	f_0 (q) = \frac{1}{(q)_\infty}
	\sum_{n \ge 0} \sum_{-n \le j \le n} (-1)^j q^{(5n^2 - 2j^2 + n)/2} (1 - q^{4n+2}).
	\]
	ただし$ (q)_\infty := \prod_{n=1}^{\infty} (1 - q^n) $.
\end{thm}

この表示式で着目したいのが$ q $の肩に二次形式が乗っていることで, となると思い起こされるのはいつものテータ関数である. 
この見方は上の表示式を少し整えることで一層明白になる. 

\begin{cor} \label{cor:mock_indefinite}
	\[
	f_0 (q) = \frac{1}{(q)_\infty}
	\sum_{n, j \in \Z} \left( \sgn(j+n) - \sgn(j-n) \right) (-1)^j q^{(5n^2 - 2j^2 + n)/2}.
	\]	
	ただし実数$ x $に対し
	\begin{align}
		\sgn(x) &:= 
		\begin{cases}
			1 & x \ge 0, \\
			-1 & x < 0
		\end{cases}
	\end{align}
	と定める. 
\end{cor}

ここで符号などの不思議な項が現れているがそれは一旦置いておいて, $ q $の肩に乗っている二次形式への注目を続けよう. 
現れているのは$ 5n^2 - 2j^2 $という不定値の二次形式である. 
つまり右辺には\textbf{不定値テータ関数}と呼ぶべき対象が現れているのだ！
ここまで来ると\ruby{擬}{モック}テータ関数をテータ関数の類似物だとみなすことに確信が持ててくるだろう. 
そして
\begin{quote}
	\centering
	\ruby{擬}{モック}テータ関数はモジュラー変換則を持つか？
\end{quote}
という疑問は今や
\begin{quote}
	\centering
	不定値テータ関数はモジュラー変換則を持つか？
\end{quote}
という問いに変わったのである！

そこで次節以降ではこの二番目の問いについて考察していこう. 

% --------------------------------------------------------------------------

\subsection{補足: $ q $級数のEuler型表示式} \label{subsec:Eulerian_form}

% --------------------------------------------------------------------------

前項でRamanujanの\ruby{擬}{モック}テータ関数に対して「このような関数は見たことが無い」と書いたが, 実際にはこのようなタイプの無限和は$ q $級数の研究においてはRamanujan以前から現れており, 現在では「Euler型表示式 (Eulerian form)」と呼ばれている
\footnote{この用語はRamanujanによるもの（\cite[119ページ]{魅惑}）であり, 恐らく\cref{thm:Jacobi}に由来する. 
	\cref{thm:Jacobi}はEulerによるものと述べられることが多いが, Andrews~\cite{Andrews_combi}によるとJacobiの仕事が初出だそうである
	（以上の歴史的背景は松坂俊輝氏に教わった）. 
	そのような理由から私にはあまり良い用語だとは思えない. }. 
本項ではその例を紹介する. 
なお本項の内容はZwegersの不定値テータ関数の解説とは直接関係しないので, そちらを優先したい方は読み飛ばして頂いて構わない. 

まずは$ q $級数の研究で頻出するPochchammer記号を準備しておこう. 

\begin{dfn}[Pochhammer記号]
	複素数$ a $と$ n \in \Z_{\ge 0} \cup \{ \infty \} $に対し
	\[
	(a; q)_n = (a)_n :=
	\begin{cases}
		1 & n=0, \\
		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) & n \in \Z_{>0}, \\
		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) \cdots & n = \infty
	\end{cases}
	\]
	と書く. 
\end{dfn}

それでは\ruby{擬}{モック}テータ関数に類する表示式を紹介しよう. 
まずは$ q $級数の中で最も古い歴史を持つ, 分割数の母関数から始める. 

\begin{thm}[Jacobi, {\cite[式 (8.2)]{整数の分割}}]
	\label{thm:Jacobi}
	\[
	\frac{1}{(q)_\infty} = \sum_{n=0}^{\infty} \frac{q^{n^2}}{(q)_n^2}.
	\]
\end{thm}

続けて紹介するのはRogers--Ramanujan恒等式と呼ばれる二つの等式である. 

\begin{thm}[Rogers--Ramanujan恒等式, {\cite[8.4節]{整数の分割}}]
	\begin{align}
		\frac{1}{(q; q^5)_\infty (q^4; q^5)_\infty} 
		&=
		\sum_{n=0}^{\infty} \frac{q^{n^2}}{(q)_n},
		\\
		\frac{1}{(q^2; q^5)_\infty (q^3; q^5)_\infty} 
		&=
		\sum_{n=0}^{\infty} \frac{q^{n^2 + n}}{(q)_n}.
	\end{align}
\end{thm}

この恒等式はこのように何気なく紹介されるとつい読み飛ばしてしまいそうになるが, 実際には深く考察すればするほど奥深い非常に重要な定理であり, 近年では丸一冊掛けてこの恒等式について解説する書籍が出版されたほどである（\cite{魅惑}）. 

Euler型表示式はRamanujan以前のRogersの仕事にも表れている. 

\begin{thm}[{Rogers~\cite[pp.~333, Equation (6)]{Rogers}, \cite[240ページ, 式 (A.200)]{魅惑}}]
	\begin{align}	
		\sum_{n \in \Z} \sgn(n) q^{(3n^2 + n)/2}
		=
		\sum_{n=0}^{\infty} \frac{(-1)^n q^{n^2 + n}}{(-q)_n}.
	\end{align}
	ただしここで\cref{cor:mock_indefinite}と同様に$ \sgn(0) := 1 $と定義していることに注意する. 
\end{thm}

この定理の左辺に現れる無限級数をRogersは\ruby{偽}{フォルス}テータ関数と呼んでいる. 
正定値二次形式が$ q $の指数に現れながら符号も現れているのが特徴である. 

Ramanujanはこれらの結果に知悉しており, 非常に多くの変種を発見している. 
\ruby{擬}{モック}テータ関数の発見にはそのような知的土壌があったものと推察される. 

またこれら$ q $級数の研究からは, Ramanujanの\ruby{擬}{モック}テータ関数を研究するには\textbf{まず$ q $級数として取り扱う}ことで取り回しの良い表示式を得ることが出発点になると考えられるだろう. 
AndrewsやHickersonによって与えられた\ruby{擬}{モック}テータ関数の不定値テータ関数表示というのは正にそのような取り回しの良い表示式である. 
そしてそのような表示式が既に得られている現在では, Ramanujanによって与えられたEuler型表示式としての定義は最早忘れてしまい, 不定値テータ関数を新たな興味の対象として研究していく方針が取れる. 
前項の最後に述べたのはまさにこのような方針である. 

しかしながら疑問も残る. 
本当に\ruby{擬}{モック}テータ関数の$ q $級数的側面を忘れてしまっても良いのだろうか？
本項で紹介した種々の公式はどれも非常に非自明で意味ありげであり, 進路こそ見えないものの研究の余地は大いに残されているように思われる. 
Zwegersによって\ruby{擬}{モック}テータ関数のモジュラー形式としての側面が解き明かされた今, 次に研究すべきは$ q $級数としての側面であると私は感じている. 

\begin{rem}
	Rogers--Ramanujan恒等式やRogersによる\ruby{偽}{フォルス}テータ関数の恒等式の変種は非常に多数発見されており, \cite[付録A]{魅惑}には計236個の変種が記載されている. 
	それら恒等式はどれも美しく, 非常に重要なものであるように思われるが, 一方で背景に潜む構造が判然としない散発的な等式群という印象も与えうる. 
	実際, それらの恒等式を証明するための強力な方法として\textbf{Bailey対 (Baliey pair)}という$ q $級数の手法があるが, これは発見的な方法であり, 背景にどのような構造が潜んでいるのかは説明できていないように思われる. 
	
	そのような問題点は「Euler型表示式」という用語にも潜んでいる. 
	この用語は数学的な定義が無くRamanujanの用法を参考に各々の数学者が各々の基準で用いているため, 「Euler型表示式である／ない」の判別が非常に曖昧なのである. 
	安直に考えればRogers--Ramanujan型の恒等式に登場する無限和は「Euler型表示式」と呼んで良いように思われるが, それら恒等式は後の時代に発見されたものになるほど非常に複雑な形をしており, 果たしてそもそも本当に「Rogers--Ramanujan型の恒等式」と呼んで良いものなのか段々分からなくなってくるのである. 
	このような問題はひとえにRogers--Ramanujan型の恒等式や\ruby{偽}{フォルス}テータ関数の恒等式の背景に潜む構造が未解明であることに起因していると思われる. 
	「Euler型表示式」がどのように数学的に定式化されるかは非常に意義深い問題であると私には感じられる. 
	このようなことも上述した\ruby{擬}{モック}テータ関数の$ q $級数的側面の研究と言えるだろう. 
\end{rem}

% --------------------------------------------------------------------------

\section{不定値テータ関数のモジュラー変換則の探求} \label{sec:indefinite_theta}

% --------------------------------------------------------------------------

それでは\cref{subsec:mock}の考察で到達した「不定値テータ関数はモジュラー変換則を持つか？」という問いについて考えていこう. 
ヒントとなるのはWatson~\cite[pp. 78]{Watson}が示した位数$ 3 $の\ruby{擬}{モック}テータ関数に対するモジュラー変換則で, それは誤差項を含んでいるという特徴があった.
ここで誤差項を含むモジュラー変換則とは, $ f(\tau) $に対しある関数$ g(\tau) $が存在して
\[
f \left( -\frac{1}{\tau} \right) = f(\tau) + g(\tau)
\]
を満たすことを指している. 
尤も任意の写像$ f \colon \bbH \to \bbC $に対して$ g(\tau) := f(-1/\tau) - f(\tau) $とおけば上の等式が満たされるので, このままでは何ら数学的意味を表していない. 
重要なのはこの$ g(\tau) $が何か意味のある関数であるということであるが, この$ g(\tau) $の意味するところをWatsonの結果から類推することは難しいように思われる. 
そこでここは別のアプローチを取り, 同じように誤差項を含むモジュラー変換則を満たす関数としてどのようなものがあったかを思い出してみよう. 
その最たる例が次節で紹介する\textbf{重さ$ 2 $のEisenstein級数}$ G_2(\tau) $である. 

% --------------------------------------------------------------------------

\subsection{重さ$ 2 $のEisenstein級数とモジュラー補完という考え方} \label{subsec:modular_completion}

% --------------------------------------------------------------------------

それでは重さ$ 2 $のEisenstein級数について紹介しよう. 
まず通常のEisenstein級数は次のように定義されていたことに注意する. 

\begin{dfn}
	$ 4 $以上の偶数$ k $に対し
	\[
	G_k (\tau) := \sum_{(m, n) \in \Z^2 \smallsetminus \{ (0, 0) \}} \frac{1}{(m\tau + n)^k}
	\]
	を\textbf{重さ$ k $のEisenstein級数}と呼ぶ. 
\end{dfn}

ここで$ k \ge 4 $という仮定は絶対収束性のために必要で, $ k $が偶数であるという仮定は無限和が$ 0 $にならないために必要である. 
しかしながら重さが$ k=2 $の場合にもEisenstein級数を以下のようにして定義することができる. 

\begin{dfn}
	\[
	G_2 (\tau) := 
	\sum_{n \in \Z \smallsetminus \{ 0 \}} \frac{1}{n^2} 
	+ \sum_{m \in \Z \smallsetminus \{ 0 \}} \sum_{n \in \Z} \frac{1}{(m\tau + n)^2}
	\]
	を\textbf{重さ$ 2 $のEisenstein級数}と呼ぶ. 
\end{dfn}

つまり, 二重和では絶対収束性が成り立たないので二つの一重和に分けるのである. 
このように定義すると$ G_2 (\tau) $は$ k \ge 4 $に対する$ G_k (\tau) $と全く同様のFourier展開を持つことが分かり, $ G_k (\tau) $の自然な拡張だとみなされる. 
しかしながら$ G_2 (\tau) $はモジュラー変換則を満たさない. 
これは$ k \ge 4 $に対する$ G_k (\tau) $がモジュラー変換則$ G_k (-1/\tau) = \tau^k G_k(\tau) $を満たすことは二重和の絶対収束性から従うのに対し, $ G_2 (\tau) $は二重和で定義されていないことに起因している. 
しかしながら$ G_2 (\tau) $は誤差項を含むモジュラー変換則を満たすことが知られている. 
それが次の公式である. 

\begin{prop}[{\cite[pp.~14, Equation (1.4)]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}}]
	\label{prop:G_2}
	\[
	G_2 \left( -\frac{1}{\tau} \right) = \tau^2 G_2(\tau) - 2\pi \iu \tau.
	\]
\end{prop}

\begin{rem}
	この公式はDedekindエータ関数
	\[
	\eta(\tau) := e^{2\pi\iu\tau/24}
	\prod_{n=1}^{\infty} (1-q^n)
	\]
	のモジュラー変換則
	\[
	\eta \left( -\frac{1}{\tau} \right)
	=
	\sqrt{-\iu \tau} \eta (\tau)
	\]
	と同値であることが
	\[
	\frac{d}{d\tau} \eta(\tau)
	=
	\frac{\iu}{4\pi} G_2(\tau)
	\]
	から従う（\cite[Proposition 1.2.5]{DS}）. 
	$ G_2 (\tau) $の変換公式よりもこちらのDedekindエータ関数のモジュラー変換則や, それから従うRamanujanのデルタ関数
	\[
	\Delta(\tau) := q \prod_{n=1}^{\infty} (1-q^n)^{24}
	= \eta(\tau)^{24}
	\]
	のモジュラー変換則$ \Delta(-1/\tau) = \tau^{12} \Delta(\tau) $の方に見覚えがある方もいるかもしれない. 
\end{rem}

実は少し工夫すると\cref{prop:G_2}は次のように言い換えられる. 

\begin{prop}[{\cite[Exercise 1.2.8(d)]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}の証明中, \cite[Lemma 6.2]{BFOR}}]
	\label{prop:G_2_completion}
	\[
	\widehat{G}_2 (\tau) := G_2(\tau) - \frac{\pi }{\Im (\tau)}
	\]
	とおくと$ \widehat{G}_2 (-1/\tau) = \tau^2 \widehat{G}_2 (\tau) $が成り立つ.
\end{prop}

この$ \widehat{G}_2 (\tau) $は\textbf{重さ$ 2 $の非正則Eisenstein級数 (nonholomorphic Eisenstein series of weight $ 2 $)}と呼ばれている. 
\cref{prop:G_2_completion}の証明は$ \pi / \Im (\tau) $が$ G_2(\tau) $と同じ変換則を満たすことから従う. 

この$ \widehat{G}_2 (\tau) $のように, 誤差項付きモジュラー変換則を満たす関数に適切な補正関数を加えることで完全なモジュラー変換則を満たすようにする方法は現在では\textbf{モジュラー補完 (modular completion)}と呼ばれている. 
この方法のメリットとしては, $ G_2(\tau) $が満たす変換則の本質のようなものを見抜いているように見えることや, $ \tau \mapsto -1/\tau $という変換以外の一般の$ \SL_2(\Z) $に対する変換も直ちに記述できることが挙げられる. 

そこで以下では, \cref{subsec:mock}の最後に挙げた
\begin{quote}
	\centering
	不定値テータ関数はモジュラー変換則を持つか？
\end{quote}
という問いから一歩先に進んで
\begin{quote}
	\centering
	不定値テータ関数をモジュラー補完できるか？
	すなわち, 不定値テータ関数に補正関数を加えることで完全なモジュラー変換則を満たすようにできるか？
\end{quote}
という問いを考察していこう. 

\begin{rem} \label{rem:Hecke_trick}
	\cref{prop:G_2_completion}でいきなり登場した$ \widehat{G}_2 (\tau) $を一体どのように見つけたのだろうかと疑問に思う方もいるだろう. 
	一つの回答は「Heckeのトリック (Hecke's trick)」を用いることである. 
	これは複素変数$ s $を持つ新たな関数
	\[
	G_2 (\tau, s) := \sum_{(m, n) \in \Z^2 \smallsetminus \{ (0, 0) \}} \frac{1}{(m\tau + n)^2 \abs{m\tau + n}^{2s}}
	\]
	を考える手法である. 
	この関数は\textbf{重さ$ 2 $の実解析的Eisenstein級数 (real analytic Eisenstein series of weight $ 2 $)}と呼ばれており, 
	複素変数$ s $について$ \Re(2+2s) > 2 $の範囲で広義絶対一様収束し正則関数を定め, モジュラー変換則
	\[
	G_2 (\tau, s) = G_2 (\tau+1, s) = \tau^{2} G_2 \left( - \frac{1}{\tau}, s \right)
	\]
	を満たすことが重さ$ k \ge 4 $のEisenstein級数の場合と同様に分かる. 
	複素変数$ s $を付け加えることによって絶対収束性が担保され, モジュラー変換則が完全な形で成り立つのである. 
	そこでもしこの複素関数$ G_2 (\tau, s) $を全平面に解析接続できるなら, $ s=0 $を代入することで完全なモジュラー変換則を満たす「重さ$ 2 $のEisenstein級数のようなもの」が得られるのではないか, と期待できる. 
	この期待は実際に実現することができ, そのようにして得られる$ G_2 (\tau, s) $はまさに$ \widehat{G}_2 (\tau) $に一致するのである！
	（詳細は\cite[Theorem 4.10.2]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}の証明中, \cite[Lemma 6.2]{BFOR}を見よ. ）
	
	このような考察によって$ \widehat{G}_2 (\tau) $は二変数複素関数$ G_2 (\tau, s) $を出自に持つということが明らかになった. 
\end{rem}

\begin{rem}
	上ではモジュラー補完のメリットとして「変換則の本質のようなものを見抜いているように見える」という曖昧な書き方をしたが, これは現代の用語を用いて正確に書くと
	\begin{quote}
		\centering
		$ \widehat{G}_2 (\tau) $は\textbf{重さ$ 2 $の調和Maas形式}であり, 
		$ G_2 (\tau) $はその\textbf{正則部分}である. 
		
		従って$ G_2 (\tau) $は\textbf{重さ$ 2 $のモックモジュラー形式}である
	\end{quote}
	という主張に言い換えられる（ここで「調和Maas形式 (harmonic Maass form of weight $ 2 $)」, 「正則部分 (holomorphic part)」, 「モックモジュラー形式 (mock modular form of weight $ 2 $)」の定義はそれぞれ\cite[Definition 4.2, Definition 4.4, Definition 5.16 i)]{BFOR}を見よ）. 
	
	つまり$ G_2 (\tau) $の「変換則の本質のようなもの」は「モックモジュラー形式」として定式化されるのである. 
	不定値テータ関数に対してもこのような見方を与えたいというのがモジュラー補完を考える意義である. 
	
	なお, 実際にはモックモジュラー形式はZwegersによる不定値テータ関数のモジュラー補完の仕事を契機に定式化された概念である. 
	これは見方を変えれば, Zwegersによる不定値テータ関数のモジュラー補完は「モックモジュラー形式」という新概念の発見に繋がるほどの大発見だったということである. 
	Zwegersの仕事は言ってしまえば「特殊関数の発見」である. 
	しかしながらその発見はモックモジュラー形式の理論を展開する契機を与えた、とてもとても重要なものである. 
	
	数学の方向性として, Grothendieckによるスキーム論の構築に代表される, 舞台を理論的に自然な方向へと整備していきトップダウン方式で古典的問題を解決する方向があるように私には感じられる. 
	Zwegersの研究はそうではなく, 不定値テータ関数というたった一つの卵が孵化するまでひたすら温める方向である（このような研究方針はZwegersに限らずモジュラー形式の研究者全般にわたる傾向であるように思われる）. 
	両者は全く別物であるが, どちらも同じくらい重要な方向性であると私は考えている（駆け出しの若輩者が生意気言ってごめんなさい）. 
\end{rem}


% --------------------------------------------------------------------------

\subsection{不定値テータ関数の収束性} \label{subsec:indefinite_theta_convergency}

% --------------------------------------------------------------------------

それでは不定値テータ関数のモジュラー補完について考えていきたいところだが、その前に一度不定値テータ関数の定義を振り返っておこう。

まずは一番簡単な不定値二次形式として$ m^2 - n^2 $に対して、その不定値テータ関数をどのように定義すれば良いか考えていこう。
安直に思い付く
\[
\sum_{(m, n) \in \Z^2} q^{m^2 - n^2}
\]
はうまくいかない。
なぜなら$ m^2 - n^2 = 0 $となる$ (m, n) \in \Z^2 $は無数に存在するので定数項が収束しないし、また今$ \abs{q} < 1 $なのに$ m^2 - n^2 $はいくらでも小さな負の数を取りうるためである。
ではどのようにして「不定値二次形式$ m^2 - n^2 $のテータ関数」を定義すれば良いのだろうか。

ヒントはAndrewsによる\ruby{擬}{モック}テータ関数の「Hecke型表示」から見出せる。
Andrewsの結果を整理した表示式である\cref{cor:mock_indefinite}には
\[
\sum_{n, j \in \Z} \left( \sgn(j+n) - \sgn(j-n) \right) (-1)^j q^{(5n^2 - 2j^2 + n)/2}
\]
という式が現れていた。
\cref{subsec:mock}でこの定理を紹介したときには「符号が現れているが一旦置いておく」と述べたが、今こそ符号に着目すべき時である。
この式は当然収束する（でなければこの式は意味を持たない）が、実はこの符号こそが収束性を担保しているのである。
実際、上の式で符号の差が消滅する部分を除いて書くと
\[
\left( \sum_{\substack{n, j \in \Z, \\ j+n > 0 > j-n}} - \sum_{\substack{n, j \in \Z, \\ j+n < 0 < j-n}} \right) (-1)^j q^{(5n^2 - 2j^2 + n)/2}
\]
と変形できるが、この和の範囲では$ q $の肩に乗っている二次形式$ 5n^2 - 2j^2 $がどんどん大きな値を取ることが見て取れる。
つまり符号の差が消滅する部分というのはまさに収束性が悪い部分であり、符号の差を付け加えた結果として収束性が従うのである。

この例は係数が少し複雑なので、先ほどの$ m^2 - n^2 $という二次形式の場合に説明し直してみる。
$ m^2 - n^2 $が正となるのは$ \abs{m} > \abs{n} $のとき、すなわち$ n+m > 0 > n-m $または$ n+m < 0 < n-m $のときなので、不定値テータ関数の定義として
\[
\left( \sum_{\substack{n, j \in \Z, \\ n+m > 0 > n-m}} - \sum_{\substack{n, j \in \Z, \\ n+m < 0 < n-m}} \right) q^{m^2 - n^2}
=
\sum_{(m, n) \in \Z^2} \left( \sgn(n+m) - \sgn(n-m) \right) q^{m^2 - n^2}
\]
を採用すれば良さそうである。
このように定義した無限級数は実際に収束するので、これを「不定値テータ関数」と呼んでしまって問題ないと了承できる。

以上から不定値テータ関数は符号を用いて定義できることが分かった。

\begin{rem}
	上では$ m^2 - n^2 $が正となるための必要十分条件を考えているが、実際には十分条件さえ与えてしまえば同様に「不定値テータ関数」を定義できる。
	例えば$ \abs{m} > 2\abs{n} $のときも$ m^2 - n^2 $は正となるので
	\[
	\sum_{(m, n) \in \Z^2} \left( \sgn(2n+m) - \sgn(2n-m) \right) q^{m^2 - n^2}
	\]
	も収束する。
	これも「不定値テータ関数」と呼んでしまって差し支えないだろう。
	
	このように不定値テータ関数の定義には和の範囲を制限するための自由度がある。
	詳細は\cref{sec:Zwegers_theta}で述べるが、この自由度はZwegersの記号ではベクトル$ c_1, c_2 $の取り方に対応している。
\end{rem}


% --------------------------------------------------------------------------

\subsection{不定値テータ関数のモジュラー補完の探求} \label{subsec:}

% --------------------------------------------------------------------------

それでは
\begin{quote}
	\centering
	不定値テータ関数をモジュラー補完できるか？
	すなわち, 不定値テータ関数に補正関数を加えることで完全なモジュラー変換則を満たすようにできるか？
\end{quote}
という問いを考察していこう. 
この問いに答えるには、たった一個の補正関数を見つけることさえできれば良い。
だがどのようにして探せば良いだろうか？

重さ$ 2 $のEisenstein級数の場合は、変数を増やして解析接続したのち特殊化するというHeckeのトリックが有効だった（\cref{rem:Hecke_trick}）。
だが不定値テータ関数の場合にはそのような上手い変数の増やし方は思い付かない。
何か別な方法を考えよう。

そこで、そもそも通常のテータ関数のモジュラー変換則（\cref{prop:theta_modular_trans}）がどのように証明されたかに立ち返ってみよう。
証明のポイントはGauss関数$ e^{-\pi x^2} $がFourier変換で不変という性質を持っていることである。
この性質を利用することで固定した$ t > 0 $に対し$ f_t (x) := e^{-\pi t x^2} $のFourier変換が$ \sqrt{t} e^{-\pi  x^2/t} $になることが分かり、Poissonの和公式を用いることで$ \theta (\tau) := \sum_{n \in \Z} q^{n^2} $のモジュラー変換則$ \theta (t\iu) = \sqrt{t} \theta (-1/t\iu) $が従うのである。

そこで不定値テータ関数に対してもFourier変換で不変な関数をうまく見つけられれば同様にモジュラー変換則が成り立つ関数（すなわちモジュラー補完）を見つけられることになる。
前項での観察から$ r $変数不定値二次形式のテータ関数は一般に
\[
\sum_{n \in \Z^r} \left( \sgn(\text{$ 1 $次形式}) - \sgn(\text{$ 1 $次形式}) \right) q^{\text{不定値$ 2 $次形式}}
\]
の形で定義できると推察されるので、ここでは不定値テータ関数のモジュラー補完として
\[
\sum_{n \in \Z^r} \rho(n) q^{\text{不定値$ 2 $次形式}}
\]
という形のものを探索してみることにしよう。
ただしここで$ \rho(x) $は何らかの意味で上式の符号の項を復元するような$ \R^r $上の実解析的関数で、$ \rho(x) e^{-\pi (\text{不定値$ 2 $次形式})} $がFourier変換で不変になるようなもの（あるいは、そこまで言わなくてもFourier変換が元の$ \rho(x) e^{-\pi (\text{不定値$ 2 $次形式})} $に近い式になるもの）である。

話を簡単にするために$ \rho(x) $は一変数関数として、何らかの意味で符号関数$ \sgn(x) $を復元し、$ \rho(x) e^{-\pi x^2} $のFourier変換が自身と近い式になるものを探すことにする（このような設定下では二次形式の不定値性は意味をなさなくなるが、今は気にせず後で考えることにする）。
ここで「何らかの意味で$ \sgn(x) $を復元する」というのは非常に曖昧な言葉遣いだが、思い切って「$ \sgn(x) $を滑らかに補完する」と解釈してみる。
符号関数$ \sgn(x) $は原点で不連続な階段状の関数だが、段差を滑らかに繋いだ関数として$ \rho(x) $を見つけてこようというわけである。
そのような特徴を持つ関数は一般に「シグモイド曲線」と呼ばれており
\footnote{グラフの形がギリシャ文字のシグマ$ \sigma $の異体字$ \varsigma $に似ていることに由来する。}、
候補として色々な関数がある。
例えば$ \arctan(x) $や$ \tanh(x) $がそれである。
それら関数$ f(x) $に対して一つずつ$ f(x) e^{-\pi x^2} $のFourier変換を計算し、自身と近い式になる$ f(x) $が見つかればそれが探していた$ \rho(x) $である。

つまり「Fourier変換が近い式になる」という「ガラスの靴」に合うような「シンデレラ」こと$ \rho(x) $を探すことが目標である。
Zwegersがどのようにしてシンデレラを見つけたのか私は知らないが、一つ考えられるやり方は上に書いたように王子様よろしく一人一人のシグモイド曲線に対してガラスの靴を履いてもらう方法である。
だがここでは私なりのシンデレラの探し方を紹介してみよう。
それはガラスの靴を一生懸命眺めてみて持ち主がどんな人物なのかを推測する方法である
\footnote{こちらはより数学者らしい方法と言えるかもしれない。王子様が数学者だったらガラスの靴からシンデレラをプロファイリングして探しただろうか？}。

それではガラスの靴を詳しく見ていこう。
まずはともあれ$ f(x) e^{-\pi x^2} $のFourier変換を計算することが先決だ。
記号の確認のためにFourier変換の定義と諸性質を振り返っておこう。

\begin{dfn}
	急減少関数$ f \colon \R \to \bbC $に対し、そのFourier変換を
	\[
	\widehat{f}(x) := \int_{-\infty}^{\infty} f(y) e^{-2\pi\iu xy} dy
	\]
	で定める。
\end{dfn}

\begin{nota}
	Gauss関数を$ g(x) := e^{-\pi x^2} $で定める。
\end{nota}

\begin{lem} \label{lem:Fourier}
	急減少関数$ f, h \colon \R \to \bbC $に対し次が成立する。
	\begin{enumerate}
		\item $ \widehat{g} = g $.
		\item 実数$ a \in \R \setminus \{ 0 \} $に対し$ f_a(x) := f(ax) $とおくと
		$ \widehat{f_a}(x) = \abs{a}^{-1} f_{a^{-1}} (x) $.
		\item $ \widehat{\widehat{f}} = f_{-1} $.
		\item 急減少関数$ f $と$ h $の畳み込み積を
		\[
		f \ast h (x) := \int_{-\infty}^{\infty} f(y) h(x-y) dy
		\]
		で定めると
		\[
		\widehat{fh} = \widehat{f} \ast \widehat{h}, \quad
		\widehat{f \ast h} = \widehat{f} \widehat{h}
		\]
		 が成り立つ。
		 \item \label{item:lem:Fourier_diff}
		 整数$ n \in \Z $に対し$ \widehat{f^{(n)}} (x) = (2 \pi \iu x)^n \widehat{f}(x) $が成り立つ。
		 ただし負の整数$ -n \in \Z_{<0} $に対し
		 \[
		 f^{(-n)} := \left( \frac{d^{-1}}{dx^{-1}} \right)^n f, \quad
		 \frac{d^{-1} f}{dx^{-1}} (x) = f^{(-1)} (x) := \int_{0}^{x} f(y) dy
		 \]
		 とおく.
	\end{enumerate}
\end{lem}

これらの基本性質を用いるとガラスの靴について次が分かる。

\begin{lem}
	急減少関数$ f \colon \R \to \bbC $に対し$ \widehat{fg}(x) = (f \ast g)(-\iu x) g(x)  $.
\end{lem}

\begin{proof}
	\begin{align}
		&\widehat{fg}(x) 
		=
		(\widehat{f} \ast \widehat{g}) (x)
		=
		(\widehat{f} \ast g) (x)
		=
		\int_{-\infty}^{\infty} \widehat{f} (y) g(x-y) dy
		=
		\int_{-\infty}^{\infty} \widehat{f} (y) e^{-\pi (x-y)^2} dy
		\\
		= \,
		&g(x) \int_{-\infty}^{\infty} \widehat{f} (y) g(y) e^{2\pi xy} dy
		=
		g(x) \widehat{(\widehat{f} g)} (x \iu)
		=
		g(x) ( \widehat{\widehat{f}} \ast \widehat{g}) (x \iu)
		\\
		= \,
		&g(x) ( f_{-1} \ast g) (x \iu)
		=
		g(x) ( f \ast g_{-1}) (-x \iu)
		=
		g(x) ( f \ast g) (-x \iu).
	\end{align}
	ただし最後から二番目の等式変形では畳み込み積の性質$ f_{-1} \ast h =  (f \ast h_{-1})_{-1} $を用いた。
\end{proof}

この補題から$ (f \ast g)(-\iu x) $が$ f(x) $に近い式になるような$ f $こそがシンデレラであることが分かる。
ここで「近い式」というのは曖昧な表現だが、思い切って「$ (f \ast g)(x) $が$ f(x) $に近い式」と言い換えてしまうことにしよう。
この条件は畳み込み積が現れており扱いにくいので、Fourier変換することで「$ \widehat{f} g $が$ \widehat{f} $に近い式」という$ \widehat{f} $に関する条件に言い換えてみる。
この条件はかなり分かりやすい形をしているので、これを詳しく見ていくことにしよう。
まず単に$ \widehat{f} g = \widehat{f} $という条件を考えると$ \widehat{f} = 0 $となってしまい意味をなさない。
そこで「近い式」の意味をうまく汲み取りつつ$ \widehat{f} $を探す必要がある。
ここは気合と直感が要求される部分である。
シンデレラを探すのに安楽椅子探偵では力不足で、やはりどこかで自分の足を動かして頑張る必要があるということなのだろう。

さて、頑張ってそのような$ \widehat{f} $を探してみると、例えば$ \widehat{f} = g $とおくと
$ \widehat{f} g (x) = g^2 (x) = g(\sqrt{2} x) = \widehat{f} (\sqrt{2} x) $
が分かる。
これは「近い式」と言ってしまって良いだろう。
だが$ \widehat{f} = g $すなわち$ f = g $が探していたシンデレラかというと、そうではない。
$ g $はシグモイド曲線でないためである。
そもそも上では何も考えずに$ f $のFourier変換$ \widehat{f} $を考えていたが、今$ f $はシグモイド曲線で急減少関数ではないためFourier変換は定義できないのである。

だが諦めてはいけない。
関数方程式の解を見つける有効な方法として、その方程式がどのような対称性を持つか考察するという方法がある。
ここで「対称性」と言っているのは何らかの群が解空間に作用するかということを指しており、これは平たく言ってしまえば一つ解が与えられたときにそこから新しい解を作る方法があるかということである。
今考えている元々の関数方程式は「$ f \ast g $が$ f $に近い」で、その解として$ f = g $があるということが分かっている（実際には今は曖昧な状況を考えているので「関数方程式」や「解」という数学用語を使うのは相応しくないが、簡単のためにこう書くことにする）。

さて、この関数方程式はどのような対称性を持つだろうか？
ここも気合と直感が要求される部分だが、頑張って探すと$ f $が解ならその微分$ f' $も解であることに気付けるかもしれない（これは畳み込み積の性質
$ (f \ast h)' = f \ast h' $から分かる）。
すると同様の議論から任意の正整数$ n \in \Z_{>0} $に対して$ f^{(n)} $も解になることが分かる（$ n < 0 $のときの$ f^{(n)} $の定義は\cref{lem:Fourier} \cref{item:lem:Fourier_diff}参照）。
これは群作用にはなっていない。$ \Z_{>0} $が加法について逆元を持たないためである。
だが$ n < 0 $のときにも\cref{lem:Fourier} \cref{item:lem:Fourier_diff}のように$ f^{(n)} $を定義することで、$ n < 0 $でも$ f^{(n)} $が解になり、考えている関数方程式に群$ \Z $が作用することが分かるのである。

さて、以上のことから任意の$ n \in \Z $に対し$ f = g^{(n)} $が関数方程式の解であることが分かった。
そこで$ g^{(n)} $がシグモイド曲線となるような整数$ n \in \Z $が存在するかを考えてみよう。
$ n>0 $のときは$ g^{(n)} $は$ g $と同様に急減少関数となるので候補から除外する。
となると考えるべきは$ n < 0 $のときだが、実はなんと$ g^{(-1)} $はシグモイド曲線になるのである！
実際、\textbf{誤差関数}
\[
\erf(x) := \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt
\]
というシグモイド曲線について$ g^{(-1)} (x) = 2^{-1} \erf(\sqrt{\pi} x) $が成り立つ！

このようにして、探し求めていたシンデレラは誤差関数$ \erf(x) $だったことが判明した！
ここからは仕上げ作業として元の不定値テータ関数の設定に戻り、きちんとモジュラー変換則が成り立つように係数を調整する必要があるが、そのような作業はシンデレラが見つかった今では似合うドレスを仕立てるようなもので、真面目に取り組めば必ずできることである。

それではいよいよ次節ではZwegersによる不定値テータ関数のモジュラー補完の定義を述べていこう。



% --------------------------------------------------------------------------

\subsection{余談: Heckeの不定値テータ関数} \label{subsec:Hecke_theta}

% --------------------------------------------------------------------------

本項ではHeckeの不定値テータ関数というものを簡単に紹介する. 
なお本項の内容はZwegersの不定値テータ関数の解説とは直接関係しないので, そちらを優先したい方は読み飛ばして頂いて構わない. 

二次形式$ Q(m, n) $が正定値の場合のテータ関数の候補としてまず初めに考えられるのがHeckeの不定値テータ関数である. 
正確な定義は述べないが, これは今の場合
\begin{align}
	\vartheta_Q (\tau) 
	&:=
	\sum_{l = {}^t\!(m, n) \in \Z^2 / \SL_2(\Z)_Q, \, Q(l) > 0} \sgn_0(m) q^{Q(l)}, 
	\\
	\vartheta_Q^* (\tau)
	&:=
	\sum_{l = {}^t\!(m, n) \in \Z^2 / \SL_2(\Z)_Q} \sgn_0(m) q^{\abs{Q(l)}}
\end{align}
のように定義されるものである. 







% --------------------------------------------------------------------------

\section{Zwegersの不定値テータ関数} \label{sec:Zwegers_theta}

% --------------------------------------------------------------------------



% --------------------------------------------------------------------------

\subsection{Zwegersの不定値テータ関数の定義と\ruby{擬}{モック}モジュラー性} \label{subsec:Zwegers_theta_def}

% --------------------------------------------------------------------------


まずZwegersの不定値テータ関数の定義を述べる. 
なお本稿では二変数二次形式のみ扱うこととする. 
本節を通して以下の記号を固定する. 

\begin{symb}
	不定値対称行列$ S \in \Sym_2(\Z) $.
\end{symb}

これに対し次の記法を定めておく. 

\begin{dfn}
	不定値二次形式$ Q(l) := {}^t\!l S l /2, \, l \in \Z^2 $.
\end{dfn}

このときZwegersの不定値テータ関数は以下のように定義される. 

\begin{dfn}[{\cite[Equation 8.23]{BFOR}, Zwegers~\cite[Section 2.2]{Zwegers_thesis}}]
	\label{dfn:Zwegers_theta}
	\leavevmode %強制的な改行
	\begin{itemize}
		\item 不定値対称行列$ S \in \Sym_2(\Z) $,
		\item 不定値二次形式$ Q(n) := {}^t\!n S n, \, n \in \Z^2 $,
		\item ベクトル$ \lambda, \lambda' \in \R^2 $であって$ Q(\lambda), Q(\lambda'), {}^t\!\lambda S \lambda' < 0 $なるもの,
		\item ベクトル$ \gamma, \delta \in \R^2 $,
		\item ベクトル$ z = \gamma \tau + \delta \in \bbC^2 $
	\end{itemize}
	に対し
	\begin{align}
		\vartheta_{S, \lambda, \lambda'} \left( z; \tau \right)
		&:=
		\sum_{l \in \Z^2}
		\left(\sgn_0 \left( {}^t\!\lambda S (\gamma + l) \right) - \sgn_0( {}^t\!\lambda' S (\gamma + l) ) \right)
		\bm{e} \left( {}^t\!z S l \right) q^{Q(l)/2}
		\\
		&=
		\bm{e} \left( -{}^t\!\gamma S \delta \right) q^{-Q(\gamma)/2}		
		\sum_{l \in \gamma + \Z^2}
		\left(\sgn_0( {}^t\!\lambda S l ) - \sgn_0( {}^t\!\lambda' S l ) \right)
		\bm{e} \left( {}^t\!\delta S l \right) q^{Q(l)/2}
	\end{align}
	とおき, これを\textbf{Zwegersの不定値テータ関数}と呼ぶ. 
\end{dfn}

\begin{thm}[{\cite[Theorem 8.26]{BFOR}, Zwegers~\cite[Proposition 2.4]{Zwegers_thesis}}]
	Zwegersの不定値テータ関数を定める無限級数は収束する. 
\end{thm}

Zwegersの不定値テータ関数が持つ最も重要な性質である\ruby{擬}{モック}モジュラー性について見ていくことにする. 
それは次のように定式化される. 

\begin{thm}[{\cite[Theorem 8.30]{BFOR}}]
	\cref{dfn:Zwegers_theta}の設定下で$ \lambda, \lambda' \in \Z^2 $であり, それらの各成分は互いに素だと仮定する. 
	このとき$ \vartheta_{S, \lambda, \lambda'} \left( z; \tau \right) $は重さ$ 1 $のベクトル値混合\ruby{擬}{モック}モジュラー形式 (vector-valued mixed mock modular form) の成分となる. 
	特に$ \vartheta_{S, \lambda, \lambda'} \left( z; \tau \right) $はある合同部分群$ \Gamma \subset \SL_2(\Z) $に関する重さ$ 1 $の混合\ruby{擬}{モック}モジュラー形式である. 
\end{thm}

ここで混合\ruby{擬}{モック}モジュラー形式は以下のように定義される概念である. 

\begin{dfn}[{\cite[Definition 13.1]{BFOR}}]
	\textbf{重さ$ k $の混合調和Maass形式}%, もしくは\textbf{深さ$ 2 $, 重さ$ k $の調和Maass形式}
	とは有限和$ f_1(\tau) g_1(\tau) + \cdots + f_n(\tau) g_n(\tau) $で表される関数であって, 各$ f_i(\tau) $は重さ$ k_i $の弱正則モジュラー形式であり各$ g_i(\tau) $は重さ$ l_i $の制御可能増大度の調和Maass形式 (harmonic Maass form of manageable growth, \cite[Definition 4.1]{BFOR}) であり各$ 1 \le i \le n $に対し$ k_i + l_i = k $を満たすもののことである. 
	重さ$ k $の混合調和Maass形式の正則部分を\textbf{混合\ruby{擬}{モック}モジュラー形式}と呼ぶ. 
\end{dfn}




% --------------------------------------------------------------------------

\subsection{} \label{subsec:}

% --------------------------------------------------------------------------








% --------------------------------------------------------------------------

\subsection{} \label{subsec:}

% --------------------------------------------------------------------------












% --------------------------------------------------------------------------

\section{Vign\'{e}raの結果との関係} \label{sec:}

% --------------------------------------------------------------------------






% --------------------------------------------------------------------------

\section{} \label{sec:}

% --------------------------------------------------------------------------





% --------------------------------------------------------------------------

\section*{謝辞}

% --------------------------------------------------------------------------


% --------------------------------------------------------------------------
%		参考文献
% --------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{indefinite_theta}
% 日本語の書籍タイトルがゴシック体になる. 見苦しいようなら\emphコマンドを書き換える. 

% --------------------------------------------------------------------------
\end{document}
% --------------------------------------------------------------------------