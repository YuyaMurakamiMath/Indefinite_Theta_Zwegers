\documentclass[11pt,b5paper,oneside,lualatex]{ltjsarticle} % LuaLaTeXの場合
%\documentclass[11pt,a4paper,oneside,titlepage,lualatex]{ltjsreport} % 表紙付き, 章から始まる形式

%SumatraPDFの逆順検索でエラーが出た時は以下のコマンドラインをSumatraPDFの設定→オプションで入力する
%"C:\Program Files (x86)\TeXstudio\texstudio.exe" "%f" -line %l

\usepackage{luatexja} % ltjclasses, ltjsclasses を使うときはこの行不要
\usepackage[marginparwidth=0pt,margin=10truemm]{geometry} % 余白の設定
% スマホやタブレットでも読みやすいB5サイズの文書を書くときは, 1行目の\documentclassのオプションで「a4paper」を「b5paper」にして, 余白設定はmargin=10truemmにすると自分好み

% --------------------------------------------------------------------------
%		パッケージとコマンド
% --------------------------------------------------------------------------

\usepackage{mypackage} % よく使うパッケージ. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmypackage.styを読み込む
\usepackage{mycommand} % 自分で定義したコマンド. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmycommand.styを読み込む

\usetikzlibrary{knots}

%\usetikzlibrary{graphs,graphs.standard,graphdrawing} % TikZでグラフを描く
%\usegdlibrary{trees,force,layered} %graphdrawingの子ライブラリ

\DeclareMathOperator{\WRT}{WRT}
\DeclareMathOperator{\perm}{perm}

% --------------------------------------------------------------------------
%		ハイパーリンク
% --------------------------------------------------------------------------

%目次にもハイパーリンクが付く. プリアンブルのできるだけ後ろに書く. 
\usepackage[luatex, pdfencoding=auto,hypertexnames=false]{hyperref}
\hypersetup{% hyperrefオプションリスト
	colorlinks=true,
	linkcolor=DarkGoldenrod, % リンクの色
	citecolor=SlateBlue, % 引用文献の色
	urlcolor=violet, % URLの色
}

% --------------------------------------------------------------------------
%		定理環境と相互参照
% --------------------------------------------------------------------------

% 参照番号の設定
\numberwithin{equation}{section} % 式番号
\newtheorem{theoremcounter}{}[section] % 定理番号のオプションを選択. [section]を[chapter]にすれば章番号から始まり「定理 1.1.1」のようになる.
\newtheorem{exercisecounter}{}[] % 演習問題番号のオプションを選択.

% 自作スタイルファイル読み込み
\usepackage{mytheorem} % cleverefパッケージによる定理環境と相互参照. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmytheorem.styを読み込む. \usepackage{hyperref}の後に書く. 

%\usepackage{myprogram} % ハイライト付きソースコード. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmyprogram.styを読み込む

% --------------------------------------------------------------------------
\begin{document}
% --------------------------------------------------------------------------

\title{Zwegersの不定値テータ関数}
\author{村上友哉}
\date{\today}

\maketitle

%シンプルな目次
\tableofcontents

% --------------------------------------------------------------------------

\section{導入と主結果} \label{sec:intro}

% --------------------------------------------------------------------------



本稿の構成を述べる. 
\cref{sec:mock}ではZwegersの研究の動機となったRamanujanのモックテータ関数について説明する.
\cref{sec:indefinite_theta}では
\cref{sec:Zwegers_theta}では

本稿を通して以下の記号を用いる. 

\begin{symb}
	\begin{itemize}
		\item 複素数$ \tau $であって$ \Im(\tau) > 0 $なるもの.
		\item 絶対値が$ 1 $未満の複素数$ q := e^{2\pi\iu\tau} $.
	\end{itemize}
\end{symb}

% --------------------------------------------------------------------------

\section{Ramanujanの\ruby{擬}{モック}テータ関数と不定値テータ関数} \label{sec:mock}

% --------------------------------------------------------------------------

Zwegersによる不定値テータ関数の研究の動機にはRamanujanの\ruby{擬}{モック}テータ関数がある. 
そこで本節ではRamanujanの\ruby{擬}{モック}テータ関数の研究をかいつまんで紹介し, 不定値テータ関数とどのように関係するかを解説する. 

% --------------------------------------------------------------------------

\subsection{\ruby{擬}{モック}テータ関数からの研究の動機} \label{subsec:mock}

% --------------------------------------------------------------------------

Ramanujanがその最期にHardyへと宛てた手紙には, 彼が\textbf{\ruby{擬}{モック}テータ関数}と称する非常に奇妙な無限級数が記されていた. 
それがどのくらい奇妙なものかは実例を挙げれば一目瞭然である. 

\begin{dfn}[Ramanujanの位数$ 5 $の\ruby{擬}{モック}テータ関数]
	\[
	f_0(q) :=
%	\sum_{n=0}^{\infty} \frac{q^{n^2}}{(-q)_n}
%	=
	1 + \sum_{n=1}^{\infty} \frac{q^{n^2}}{(1+q)(1+q^2) \cdots (1+q^n)}.
	\]
\end{dfn}

%ただしここで$ (a)_n $はPochchammer記号で, 以下のように定義される. 
%
%\begin{dfn}[Pochhammer記号]
%	複素数$ a $と$ n \in \Z_{\ge 0} \cup \{ \infty \} $に対し
%	\[
%	(a)_n :=
%	\begin{cases}
%		1 & n=0, \\
%		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) & n \in \Z_{>0}, \\
%		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) \cdots & n = \infty.
%	\end{cases}
%	\]
%\end{dfn}

「今まで数学をやってきて, このような関数は見たことが無い」というのが私の率直な感想である. 
何しろ無限和の中に多項式の積が入り込んでいるのだ. 
このような関数を一体どのようにして研究できるというのだろうか？

だが投げ出す前に少し落ち着いて考えてみよう. 
「\ruby{擬}{モック}テータ関数」というRamanujanの命名は意味ありげである. 
このように名付けたからにはRamanujanはテータ関数に類似した性質を期待していたのだろう. 
しかしながら, 本来のテータ関数は正整数$ r $と正定値対称行列$ S \in \GL_r(\R) $に対して
\[
\theta_S (\tau) :=
\sum_{n \in \Z^r} q^{{}^t\!n S n/2}, \quad
q := e^{2\pi\iu\tau}
\]
と定義されるもので, Ramanujanの\ruby{擬}{モック}テータ関数とは似ても似つかない. 
果たして本当に類似した性質など期待できるだろうか？

だが「それでも何かありそうだ」と思わせるのがRamanujanである. 
もし仮に通常のテータ関数と\ruby{擬}{モック}テータ関数の間に類似した性質があるとすれば, それは何だろうか？

安直に思いつくのはテータ関数のモジュラー変換則である. 

\begin{prop}[テータ関数のモジュラー変換則, {\cite[命題2.5.1]{高瀬}}]
	\[
%	\theta_S (\tau + 1) = \theta_S (\tau), \quad
	\theta_S \left( -\frac{1}{\tau} \right) =
	\sqrt{\det S} \sqrt{-\iu \tau}^r \theta_S (\tau).
	\]
\end{prop}

この性質は非常に重要である. 
例えば最も簡単な$ r = 1, S = 1 $の場合にこの性質を用いることでRiemannゼータ関数の関数等式を得ることができる. 
またこの性質はテータ関数がモジュラー形式をなすことを意味しており, モジュラー形式の理論を応用することで様々な数論的帰結を得ることが可能である. 

そこで\textbf{\ruby{擬}{モック}テータ関数に対してもモジュラー変換則が満たされること}を期待してみたくなる. 
だがそれはいくら何でも楽観的過ぎるだろうか？

状況証拠はRamanujanの手紙に既に記されていた. 
Ramanujanは
\begin{itemize}
	\item \ruby{擬}{モック}テータ関数たちが非自明な関係式を満たすこと
	\item \ruby{擬}{モック}テータ関数のFourier係数の漸近的性質
\end{itemize}
を発見していたが, これらは共にモジュラー形式が持つ性質である. 
この期待を単に楽観的と片付けるのは勿体無さそうだ. 

状況証拠は\ruby{擬}{モック}テータ関数の研究が進むにつれて更に集まり始めた. 
例えばWatson~\cite[pp. 78]{Watson}は位数$ 3 $の\ruby{擬}{モック}テータ関数に対してモジュラー変換則を記述することに成功している. 
それは通常のテータ関数のような単純な形ではなく誤差項を含んでおり, 非常に驚くべき式ではあるものの「確かに記述できるのは分かったけどこれで理解できたとは思えないなあ」と筆者には感じられる式である. 
Watsonの証明には拡張性に乏しく全ての\ruby{擬}{モック}テータ関数に適用することが難しいという問題もあった（彼の方法は\ruby{擬}{モック}テータ関数の「Appell--Lerch型和」と呼ばれる表示式に基づく巧妙なものである）. 

更にその後, AndrewsやHickersonが\ruby{擬}{モック}テータ関数の「Hecke型表示」を発見した. 
それは例えば次のような表示式である. 

\begin{thm}[Andrews~{\cite[Equation (1.4)]{Andrews_5_7}}]
	\[
	f_0 (q) = \frac{1}{(q)_\infty}
	\sum_{n \ge 0} \sum_{-n \le j \le n} (-1)^j q^{(5n^2 - 2j^2 + n)/2} (1 - q^{4n+2}).
	\]
	ただし$ (q)_\infty := \prod_{n=1}^{\infty} (1 - q^n) $.
\end{thm}

この表示式で着目したいのが$ q $の肩に二次形式が乗っていることで, となると思い起こされるのはいつものテータ関数である. 
この見方は上の表示式を少し整えることで一層明白になる. 

\begin{cor} \label{cor:mock_indefinite}
	\[
	f_0 (q) = \frac{1}{(q)_\infty}
	\sum_{n, j \in \Z} \left( \sgn(j+n) - \sgn(j-n) \right) (-1)^j q^{(5n^2 - 2j^2 + n)/2}.
	\]	
	ただし実数$ x $に対し
	\begin{align}
		\sgn(x) &:= 
		\begin{cases}
			1 & x \ge 0, \\
			-1 & x < 0
		\end{cases}
	\end{align}
	と定める. 
\end{cor}

ここで符号などの不思議な項が現れているがそれは一旦置いておいて, $ q $の肩に乗っている二次形式への注目を続けよう. 
現れているのは$ 5n^2 - 2j^2 $という不定値の二次形式である. 
つまり右辺は\textbf{不定値テータ関数}と呼ぶべき対象が現れているのだ！
ここまで来ると\ruby{擬}{モック}テータ関数をテータ関数の類似物だとみなすことに確信が持ててくるだろう. 
そして
\begin{quote}
	\centering
	\ruby{擬}{モック}テータ関数はモジュラー変換則を持つか？
\end{quote}
という疑問は今や
\begin{quote}
	\centering
	不定値テータ関数はモジュラー変換則を持つか？
\end{quote}
という問いに変わったのである！

そこで次節以降ではこの二番目の問いについて考察していこう. 

% --------------------------------------------------------------------------

\subsection{補足: $ q $級数のEuler型表示式} \label{subsec:Eulerian_form}

% --------------------------------------------------------------------------

前項でRamanujanの\ruby{擬}{モック}テータ関数に対して「このような関数は見たことが無い」と書いたが, 実際にはこのようなタイプの無限和は$ q $級数の研究においてはRamanujan以前から現れており, 現在では「Euler型表示式 (Eulerian form)」と呼ばれている. 
\footnote{この用語はRamanujanによるもの（\cite[119ページ]{魅惑}）であり, 恐らく\cref{thm:Jacobi}に由来する. 
	\cref{thm:Jacobi}はEulerによるものと述べられることが多いが, Andrews~\cite{Andrews_combi}によるとJacobiの仕事が初出だそうである
	（以上の歴史的背景は松坂俊輝氏に教わった）. 
	そのような理由から私にはあまり良い用語だとは思えない. }
本項ではその例を紹介する. 

まずは$ q $級数の研究で頻出するPochchammer記号を準備しておこう. 

\begin{dfn}[Pochhammer記号]
	複素数$ a $と$ n \in \Z_{\ge 0} \cup \{ \infty \} $に対し
	\[
	(a; q)_n = (a)_n :=
	\begin{cases}
		1 & n=0, \\
		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) & n \in \Z_{>0}, \\
		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) \cdots & n = \infty
	\end{cases}
	\]
	と書く. 
\end{dfn}

それでは\ruby{擬}{モック}テータ関数に類する表示式を紹介しよう. 
まずは$ q $級数の中で最も古い歴史を持つ, 分割数の母関数から始める. 

\begin{thm}[Jacobi, {\cite[式 (8.2)]{整数の分割}}]
	\label{thm:Jacobi}
	\[
	\frac{1}{(q)_\infty} = \sum_{n=0}^{\infty} \frac{q^{n^2}}{(q)_n^2}.
	\]
\end{thm}

続けて紹介するのはRogers--Ramanujan恒等式と呼ばれる二つの等式である. 

\begin{thm}[Rogers--Ramanujan恒等式, {\cite[8.4節]{整数の分割}}]
	\begin{align}
		\frac{1}{(q; q^5)_\infty (q^4; q^5)_\infty} 
		&=
		\sum_{n=0}^{\infty} \frac{q^{n^2}}{(q)_n},
		\\
		\frac{1}{(q^2; q^5)_\infty (q^3; q^5)_\infty} 
		&=
		\sum_{n=0}^{\infty} \frac{q^{n^2 + n}}{(q)_n}.
	\end{align}
\end{thm}

この恒等式はこのように何気なく紹介されるとつい読み飛ばしてしまいそうになるが, 実際には深く考察すればするほど奥深い非常に重要な定理であり, 近年では丸一冊掛けてこの恒等式について解説する書籍が出版されたほどである（\cite{魅惑}）. 

Euler型表示式はRamanujan以前のRogersの仕事にも表れている. 

\begin{thm}[{Rogers~\cite[pp.~333, Equation (6)]{Rogers}, \cite[240ページ, 式 (A.200)]{魅惑}}]
	\begin{align}	
		\sum_{n \in \Z} \sgn(n) q^{(3n^2 + n)/2}
		=
		\sum_{n=0}^{\infty} \frac{(-1)^n q^{n^2 + n}}{(-q)_n}.
	\end{align}
	ただしここで\cref{cor:mock_indefinite}と同様に$ \sgn(0) := 1 $と定義していることに注意する。
\end{thm}

この定理の左辺に現れる無限級数をRogersは\ruby{偽}{フォルス}テータ関数と呼んでいる。
正定値二次形式が$ q $の指数に現れながら符号も現れているのが特徴である。

Ramanujanはこれらの結果に知悉しており、非常に多くの変種を発見している。
\ruby{擬}{モック}テータ関数の発見にはそのような知的土壌があったものと推察される。

またこれら$ q $級数の研究からは, Ramanujanの\ruby{擬}{モック}テータ関数を研究するには\textbf{まず$ q $級数として取り扱う}ことで取り回しの良い表示式を得ることが出発点になると考えられるだろう. 
AndrewsやHickersonによって与えられた\ruby{擬}{モック}テータ関数の不定値テータ関数表示というのは正にそのような取り回しの良い表示式である. 
そしてそのような表示式が既に得られている現在では、Ramanujanによって与えられたEuler型表示式としての定義は最早忘れてしまい、不定値テータ関数を新たな興味の対象として研究していく方針が取れる。
前項の最後に述べたのはまさにこのような方針である。

しかしながら疑問も残る。
本当に\ruby{擬}{モック}テータ関数の$ q $級数的側面を忘れてしまっても良いのだろうか？
本項で紹介した種々の公式はどれも非常に非自明で意味ありげであり、進路こそ見えないものの研究の余地は大いに残されているように思われる。
Zwegersによって\ruby{擬}{モック}テータ関数のモジュラー形式としての側面が解き明かされた今、次に研究すべきは$ q $級数としての側面であると私は感じている。

\begin{rem}
	Rogers--Ramanujan恒等式やRogersによる\ruby{偽}{フォルス}テータ関数の恒等式の変種は非常に多数発見されており, \cite[付録A]{魅惑}には計236個の変種が記載されている. 
	それら恒等式はどれも美しく, 非常に重要なものであるように思われるが, 一方で背景に潜む構造が判然としない散発的な等式群という印象も与えうる. 
	実際, それらの恒等式を証明するための強力な方法として\textbf{Bailey対 (Baliey pair)}という$ q $級数の手法があるが, これは発見的な方法であり, 背景にどのような構造が潜んでいるのかは説明できていないように思われる. 
	
	そのような問題点は「Euler型表示式」という用語にも潜んでいる. 
	この用語は数学的な定義が無くRamanujanの用法を参考に各々の数学者が各々の基準で用いているため, 「Euler型表示式である／ない」の判別が非常に曖昧なのである. 
	安直に考えればRogers--Ramanujan型の恒等式に登場する無限和は「Euler型表示式」と呼んで良いように思われるが, それら恒等式は後の時代に発見されたものになるほど非常に複雑な形をしており, 果たしてそもそも本当に「Rogers--Ramanujan型の恒等式」と呼んで良いものなのか段々分からなくなってくるのである. 
	このような問題はひとえにRogers--Ramanujan型の恒等式や\ruby{偽}{フォルス}テータ関数の恒等式の背景に潜む構造が未解明であることに起因していると思われる. 
	「Euler型表示式」がどのように数学的に定式化されるかは非常に意義深い問題であると私には感じられる. 
	このようなことも上述した\ruby{擬}{モック}テータ関数の$ q $級数的側面の研究と言えるだろう。
\end{rem}

% --------------------------------------------------------------------------

\section{不定値テータ関数のモジュラー変換則の探求} \label{sec:indefinite_theta}

% --------------------------------------------------------------------------

それでは\cref{subsec:mock}の考察で到達した「不定値テータ関数はモジュラー変換則を持つか？」という問いについて考えていこう。
ヒントとなるのはWatson~\cite[pp. 78]{Watson}が示した位数$ 3 $の\ruby{擬}{モック}テータ関数に対するモジュラー変換則で、それは誤差項を含んでいるという特徴があった.
ここで誤差項を含むモジュラー変換則とは、$ f(\tau) $に対しある関数$ g(\tau) $が存在して
\[
f \left( -\frac{1}{\tau} \right) = f(\tau) + g(\tau)
\]
を満たすことを指している。
尤も任意の写像$ f \colon \bbH \to \bbC $に対して$ g(\tau) := f(-1/\tau) - f(\tau) $とおけば上の等式が満たされるので、このままでは何ら数学的意味を表していない。
重要なのはこの$ g(\tau) $が何か意味のある関数であるということであるが、この$ g(\tau) $の意味するところをWatsonの結果から類推することは難しいように思われる。
そこでここは別のアプローチを取り、同じように誤差項を含むモジュラー変換則を満たす関数としてどのようなものがあったかを思い出してみよう。
その最たる例が次節で紹介する\textbf{重さ$ 2 $のEisenstein級数}$ G_2(\tau) $である。

% --------------------------------------------------------------------------

\subsection{重さ$ 2 $のEisenstein級数とモジュラー補完という考え方} \label{subsec:modular_completion}

% --------------------------------------------------------------------------

それでは重さ$ 2 $のEisenstein級数について紹介しよう。
まず通常のEisenstein級数は次のように定義されていたことに注意する。

\begin{dfn}
	$ 4 $以上の偶数$ k $に対し
	\[
	G_k (\tau) := \sum_{(m, n) \in \Z^2 \smallsetminus \{ (0, 0) \}} \frac{1}{(m\tau + n)^k}
	\]
	を\textbf{重さ$ k $のEisenstein級数}と呼ぶ。
\end{dfn}

ここで$ k \ge 4 $という仮定は絶対収束性のために必要で、$ k $が偶数であるという仮定は無限和が$ 0 $にならないために必要である。
しかしながら重さが$ k=2 $の場合にもEisenstein級数を以下のようにして定義することができる。

\begin{dfn}
	\[
	G_2 (\tau) := 
	\sum_{n \in \Z \smallsetminus \{ 0 \}} \frac{1}{n^2} 
	+ \sum_{m \in \Z \smallsetminus \{ 0 \}} \sum_{n \in \Z} \frac{1}{(m\tau + n)^2}
	\]
	を\textbf{重さ$ 2 $のEisenstein級数}と呼ぶ。
\end{dfn}

つまり、二重和では絶対収束性が成り立たないので二つの一重和に分けるのである。
このように定義すると$ G_2 (\tau) $は$ k \ge 4 $に対する$ G_k (\tau) $と全く同様のFourier展開を持つことが分かり、$ G_k (\tau) $の自然な拡張だとみなされる。
しかしながら$ G_2 (\tau) $はモジュラー変換則を満たさない。
これは$ k \ge 4 $に対する$ G_k (\tau) $がモジュラー変換則$ G_k (-1/\tau) = \tau^k G_k(\tau) $を満たすことは二重和の絶対収束性から従うのに対し、$ G_2 (\tau) $は二重和で定義されていないことに起因している。
しかしながら$ G_2 (\tau) $は誤差項を含むモジュラー変換則を満たすことが知られている。
それが次の公式である。

\begin{prop}[{\cite[pp.~14, Equation (1.4)]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}}]
	\label{prop:G_2}
	\[
	G_2 \left( -\frac{1}{\tau} \right) = \tau^2 G_2(\tau) - 2\pi \iu \tau.
	\]
\end{prop}

\begin{rem}
	この公式はDedekindエータ関数
	\[
	\eta(\tau) := e^{2\pi\iu\tau/24}
	\prod_{n=1}^{\infty} (1-q^n)
	\]
	のモジュラー変換則
	\[
	\eta \left( -\frac{1}{\tau} \right)
	=
	\sqrt{-\iu \tau} \eta (\tau)
	\]
	と同値であることが
	\[
	\frac{d}{d\tau} \eta(\tau)
	=
	\frac{\iu}{4\pi} G_2(\tau)
	\]
	から従う（\cite[Proposition 1.2.5]{DS}）。
	$ G_2 (\tau) $の変換公式よりもこちらのDedekindエータ関数のモジュラー変換則や、それから従うRamanujanのデルタ関数
	\[
	\Delta(\tau) := q \prod_{n=1}^{\infty} (1-q^n)^{24}
	= \eta(\tau)^{24}
	\]
	のモジュラー変換則$ \Delta(-1/\tau) = \tau^{12} \Delta(\tau) $の方に見覚えがある方もいるかもしれない。
\end{rem}

実は少し工夫すると\cref{prop:G_2}は次のように言い換えられる。

\begin{prop}[{\cite[Exercise 1.2.8(d)]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}の証明中, \cite[Lemma 6.2]{BFOR}}]
	\label{prop:G_2_completion}
	\[
	\widehat{G}_2 (\tau) := G_2(\tau) - \frac{\pi }{\Im (\tau)}
	\]
	とおくと$ \widehat{G}_2 (-1/\tau) = \tau^2 \widehat{G}_2 (\tau) $が成り立つ.
\end{prop}

証明は$ \pi / \Im (\tau) $が$ G_2(\tau) $と同じ変換則を満たすことから従う。

この$ \widehat{G}_2 (\tau) $のように、誤差項付きモジュラー変換則を満たす関数に適切な補正関数を加えることで完全なモジュラー変換則を満たすようにする方法は現在では\textbf{モジュラー補完 (modular completion)}と呼ばれている。
この方法のメリットとしては、$ G_2(\tau) $が満たす変換則の本質のようなものを見抜いているように見えることや、$ \tau \mapsto -1/\tau $という変換以外の一般の$ \SL_2(\Z) $に対する変換も直ちに記述できることが挙げられる。

そこで以下では、\cref{subsec:mock}の最後に挙げた
\begin{quote}
	\centering
	不定値テータ関数はモジュラー変換則を持つか？
\end{quote}
という問いから一歩先に進んで
\begin{quote}
	\centering
	不定値テータ関数をモジュラー補完できるか？
	すなわち、不定値テータ関数に補正関数を加えることで完全なモジュラー変換則を満たすようにできるか？
\end{quote}
という問いを考察していこう。

\begin{rem}
	\cref{prop:G_2_completion}でいきなり登場した$ \widehat{G}_2 (\tau) $を一体どのように見つけたのだろうかと疑問に思う方もいるだろう。
	一つの回答は、「Heckeのトリック (Hecke's trick)」を用いることである。
	これは複素変数$ s $を持つ新たな関数
	\[
	G_2 (\tau, s) := \sum_{(m, n) \in \Z^2 \smallsetminus \{ (0, 0) \}} \frac{1}{(m\tau + n)^2 \abs{m\tau + n}^{2s}}
	\]
	を考える手法である。
	この関数は\textbf{重さ$ 2 $の実解析的／非正則Eisenstein級数 (real analytic / nonholomorphic Eisenstein series of weight $ 2 $)}と呼ばれており、
	複素変数$ s $について$ \Re(2+2s) > 2 $の範囲で広義絶対一様収束し正則関数を定め、モジュラー変換則
	\[
	G_2 (\tau, s) = G_2 (\tau+1, s) = \tau^{2} G_2 \left( - \frac{1}{\tau}, s \right)
	\]
	を満たすことが重さ$ k \ge 4 $のEisenstein級数の場合と同様に分かる。
	複素変数$ s $を付け加えることによって絶対収束性が担保され、モジュラー変換則が完全な形で成り立つのである。
\end{rem}

% --------------------------------------------------------------------------

\subsection{不定値テータ関数のモジュラー完備化の探求} \label{subsec:}

% --------------------------------------------------------------------------














% --------------------------------------------------------------------------

\subsection{余談: Heckeの不定値テータ関数} \label{subsec:Hecke_theta}

% --------------------------------------------------------------------------


二次形式$ Q(m, n) $が正定値の場合のテータ関数の候補としてまず初めに考えられるのがHeckeの不定値テータ関数である. 
正確な定義は述べないが, これは今の場合
\begin{align}
	\vartheta_Q (\tau) 
	&:=
	\sum_{l = {}^t\!(m, n) \in \Z^2 / \SL_2(\Z)_Q, \, Q(l) > 0} \sgn_0(m) q^{Q(l)}, 
	\\
	\vartheta_Q^* (\tau)
	&:=
	\sum_{l = {}^t\!(m, n) \in \Z^2 / \SL_2(\Z)_Q} \sgn_0(m) q^{\abs{Q(l)}}
\end{align}
のように定義されるものである. 

















% --------------------------------------------------------------------------

\section{Zwegersの不定値テータ関数} \label{sec:Zwegers_theta}

% --------------------------------------------------------------------------



% --------------------------------------------------------------------------

\subsection{Zwegersの不定値テータ関数の定義と\ruby{擬}{モック}モジュラー性} \label{subsec:Zwegers_theta_def}

% --------------------------------------------------------------------------


% --------------------------------------------------------------------------

\section{Zwegersの不定値テータ関数の定義の詳細} \label{sec:dfn}

% --------------------------------------------------------------------------

まずZwegersの不定値テータ関数の定義を述べる. 
なお本稿では二変数二次形式のみ扱うこととする. 
本節を通して以下の記号を固定する. 

\begin{symb}
	不定値対称行列$ S \in \Sym_2(\Z) $.
\end{symb}

これに対し次の記法を定めておく. 

\begin{dfn}
	不定値二次形式$ Q(l) := {}^t\!l S l /2, \, l \in \Z^2 $.
\end{dfn}

このときZwegersの不定値テータ関数は以下のように定義される. 

\begin{dfn}[{\cite[Equation 8.23]{BFOR}, Zwegers~\cite[Section 2.2]{Zwegers_thesis}}]
	\label{dfn:Zwegers_theta}
	\leavevmode %強制的な改行
	\begin{itemize}
		\item 不定値対称行列$ S \in \Sym_2(\Z) $,
		\item 不定値二次形式$ Q(n) := {}^t\!n S n, \, n \in \Z^2 $,
		\item ベクトル$ \lambda, \lambda' \in \R^2 $であって$ Q(\lambda), Q(\lambda'), {}^t\!\lambda S \lambda' < 0 $なるもの,
		\item ベクトル$ \gamma, \delta \in \R^2 $,
		\item ベクトル$ z = \gamma \tau + \delta \in \bbC^2 $
	\end{itemize}
	に対し
	\begin{align}
		\vartheta_{S, \lambda, \lambda'} \left( z; \tau \right)
		&:=
		\sum_{l \in \Z^2}
		\left(\sgn_0 \left( {}^t\!\lambda S (\gamma + l) \right) - \sgn_0( {}^t\!\lambda' S (\gamma + l) ) \right)
		\bm{e} \left( {}^t\!z S l \right) q^{Q(l)/2}
		\\
		&=
		\bm{e} \left( -{}^t\!\gamma S \delta \right) q^{-Q(\gamma)/2}		
		\sum_{l \in \gamma + \Z^2}
		\left(\sgn_0( {}^t\!\lambda S l ) - \sgn_0( {}^t\!\lambda' S l ) \right)
		\bm{e} \left( {}^t\!\delta S l \right) q^{Q(l)/2}
	\end{align}
	とおき, これを\textbf{Zwegersの不定値テータ関数}と呼ぶ. 
\end{dfn}

\begin{thm}[{\cite[Theorem 8.26]{BFOR}, Zwegers~\cite[Proposition 2.4]{Zwegers_thesis}}]
	Zwegersの不定値テータ関数を定める無限級数は収束する. 
\end{thm}

Zwegersの不定値テータ関数が持つ最も重要な性質である\ruby{擬}{モック}モジュラー性について見ていくことにする. 
それは次のように定式化される. 

\begin{thm}[{\cite[Theorem 8.30]{BFOR}}]
	\cref{dfn:Zwegers_theta}の設定下で$ \lambda, \lambda' \in \Z^2 $であり, それらの各成分は互いに素だと仮定する. 
	このとき$ \vartheta_{S, \lambda, \lambda'} \left( z; \tau \right) $は重さ$ 1 $のベクトル値混合\ruby{擬}{モック}モジュラー形式 (vector-valued mixed mock modular form) の成分となる. 
	特に$ \vartheta_{S, \lambda, \lambda'} \left( z; \tau \right) $はある合同部分群$ \Gamma \subset \SL_2(\Z) $に関する重さ$ 1 $の混合\ruby{擬}{モック}モジュラー形式である. 
\end{thm}

ここで混合\ruby{擬}{モック}モジュラー形式は以下のように定義される概念である. 

\begin{dfn}[{\cite[Definition 13.1]{BFOR}}]
	\textbf{重さ$ k $の混合調和Maass形式}%, もしくは\textbf{深さ$ 2 $, 重さ$ k $の調和Maass形式}
	とは有限和$ f_1(\tau) g_1(\tau) + \cdots + f_n(\tau) g_n(\tau) $で表される関数であって, 各$ f_i(\tau) $は重さ$ k_i $の弱正則モジュラー形式であり各$ g_i(\tau) $は重さ$ l_i $の制御可能増大度の調和Maass形式 (harmonic Maass form of manageable growth, \cite[Definition 4.1]{BFOR}) であり各$ 1 \le i \le n $に対し$ k_i + l_i = k $を満たすもののことである. 
	重さ$ k $の混合調和Maass形式の正則部分を\textbf{混合\ruby{擬}{モック}モジュラー形式}と呼ぶ. 
\end{dfn}




% --------------------------------------------------------------------------

\subsection{} \label{subsec:}

% --------------------------------------------------------------------------








% --------------------------------------------------------------------------

\subsection{} \label{subsec:}

% --------------------------------------------------------------------------












% --------------------------------------------------------------------------

\section{Vigneraの結果との関係} \label{sec:}

% --------------------------------------------------------------------------






% --------------------------------------------------------------------------

\section{} \label{sec:}

% --------------------------------------------------------------------------





% --------------------------------------------------------------------------

\section*{謝辞}

% --------------------------------------------------------------------------


% --------------------------------------------------------------------------
%		参考文献
% --------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{indefinite_theta}
% 日本語の書籍タイトルがゴシック体になる. 見苦しいようなら\emphコマンドを書き換える. 

% --------------------------------------------------------------------------
\end{document}
% --------------------------------------------------------------------------