\documentclass[11pt,b5paper,oneside,lualatex]{ltjsarticle} % LuaLaTeXの場合
%\documentclass[11pt,a4paper,oneside,titlepage,lualatex]{ltjsreport} % 表紙付き, 章から始まる形式

%SumatraPDFの逆順検索でエラーが出た時は以下のコマンドラインをSumatraPDFの設定→オプションで入力する
%"C:\Program Files (x86)\TeXstudio\texstudio.exe" "%f" -line %l

\usepackage{luatexja} % ltjclasses, ltjsclasses を使うときはこの行不要
\usepackage[marginparwidth=0pt,margin=10truemm]{geometry} % 余白の設定
% スマホやタブレットでも読みやすいB5サイズの文書を書くときは, 1行目の\documentclassのオプションで「a4paper」を「b5paper」にして, 余白設定はmargin=10truemmにすると自分好み

% --------------------------------------------------------------------------
%		パッケージとコマンド
% --------------------------------------------------------------------------

\usepackage{mypackage} % よく使うパッケージ. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmypackage.styを読み込む
\usepackage{mycommand} % 自分で定義したコマンド. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmycommand.styを読み込む

\usetikzlibrary{knots}

%\usetikzlibrary{graphs,graphs.standard,graphdrawing} % TikZでグラフを描く
%\usegdlibrary{trees,force,layered} %graphdrawingの子ライブラリ

\DeclareMathOperator{\WRT}{WRT}
\DeclareMathOperator{\perm}{perm}
\DeclareMathOperator{\erf}{erf}
\renewcommand{\setminus}{\smallsetminus}

% --------------------------------------------------------------------------
%		ハイパーリンク
% --------------------------------------------------------------------------

%目次にもハイパーリンクが付く. プリアンブルのできるだけ後ろに書く. 
\usepackage[luatex, pdfencoding=auto,hypertexnames=false]{hyperref}
\hypersetup{% hyperrefオプションリスト
	colorlinks=true,
	linkcolor=DarkGoldenrod, % リンクの色
	citecolor=SlateBlue, % 引用文献の色
	urlcolor=violet, % URLの色
}

% --------------------------------------------------------------------------
%		定理環境と相互参照
% --------------------------------------------------------------------------

% 参照番号の設定
\numberwithin{equation}{section} % 式番号
\newtheorem{theoremcounter}{}[section] % 定理番号のオプションを選択. [section]を[chapter]にすれば章番号から始まり「定理 1.1.1」のようになる.
\newtheorem{exercisecounter}{}[] % 演習問題番号のオプションを選択.

% 自作スタイルファイル読み込み
\usepackage{mytheorem} % cleverefパッケージによる定理環境と相互参照. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmytheorem.styを読み込む. \usepackage{hyperref}の後に書く. 

%\usepackage{myprogram} % ハイライト付きソースコード. 「C:\w32tex\share\texmf-local\tex\(好きなファイル名)」に置いたmyprogram.styを読み込む

% --------------------------------------------------------------------------
\begin{document}
% --------------------------------------------------------------------------

\title{Zwegersの不定値テータ関数}
\author{村上友哉}
\date{\today}

\maketitle

%シンプルな目次
\tableofcontents

% --------------------------------------------------------------------------

\section{本稿について} \label{sec:intro}

% --------------------------------------------------------------------------

本稿はZwegersの不定値テータ関数がどのようなものかを解説するものである. 
この関数はRamanujanの\ruby{擬}{モック}テータ関数をモジュラー形式論の枠組みで理解するためにZwegersによって導入されたもので, その後\ruby{擬}{モック}モジュラー形式という概念を導入する契機となった対象である. 

本稿では証明の細部には立ち入らず, なぜこのようなことを考えるのかというモチベーションや, 理論の源泉となる具体的な計算例を紹介することに重点を置いて解説を行う.

本稿の構成を述べる. 
\cref{sec:mock}ではZwegersの研究の動機となったRamanujanの\ruby{擬}{モック}テータ関数とその研究の問題意識について説明する.
\cref{sec:indefinite_theta}では不定値二次形式から定まるテータ関数をモジュラー形式論の枠組みで理解するためのアイデアを述べる. 
\cref{sec:Zwegers_theta}では本稿の目的であるZwegersの不定値テータ関数を紹介する. 
\cref{sec:Vigneras}ではZwegersの不定値テータ関数とVign\'{e}rasによるテータ関数を扱う枠組みとの関係を述べる. 

本稿を通して以下の記号を用いる. 

\begin{symb}
	\begin{itemize}
		\item 複素数$ \tau $であって$ \Im(\tau) > 0 $なるもの.
		\item 絶対値が$ 1 $未満の複素数$ q := e^{2\pi\iu\tau} $.
	\end{itemize}
\end{symb}

% --------------------------------------------------------------------------

\section{Ramanujanの\ruby{擬}{モック}テータ関数と不定値テータ関数} \label{sec:mock}

% --------------------------------------------------------------------------

Zwegersによる不定値テータ関数の研究の動機にはRamanujanの\ruby{擬}{モック}テータ関数がある. 
そこで本節ではRamanujanの\ruby{擬}{モック}テータ関数の研究をかいつまんで紹介し, 不定値テータ関数とどのように関係するかを解説する. 

% --------------------------------------------------------------------------

\subsection{\ruby{擬}{モック}テータ関数からの研究の動機} \label{subsec:mock}

% --------------------------------------------------------------------------

Ramanujanがその最期にHardyへと宛てた手紙には, 彼が\textbf{\ruby{擬}{モック}テータ関数}と称する非常に奇妙な無限級数が記されていた. 
それがどのくらい奇妙なものかは実例を挙げれば一目瞭然である. 

\begin{dfn}[Ramanujanの位数$ 5 $の\ruby{擬}{モック}テータ関数]
	\[
	f_0(q) :=
%	\sum_{n=0}^{\infty} \frac{q^{n^2}}{(-q)_n}
%	=
	1 + \sum_{n=1}^{\infty} \frac{q^{n^2}}{(1+q)(1+q^2) \cdots (1+q^n)}.
	\]
\end{dfn}

%ただしここで$ (a)_n $はPochchammer記号で, 以下のように定義される. 
%
%\begin{dfn}[Pochhammer記号]
%	複素数$ a $と$ n \in \Z_{\ge 0} \cup \{ \infty \} $に対し
%	\[
%	(a)_n :=
%	\begin{cases}
%		1 & n=0, \\
%		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) & n \in \Z_{>0}, \\
%		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) \cdots & n = \infty.
%	\end{cases}
%	\]
%\end{dfn}

「今まで数学をやってきて, このような関数は見たことが無い」というのが私の率直な感想である. 
何しろ無限和の中に多項式の積が入り込んでいるのだ. 
このような関数を一体どのようにして研究できるというのだろうか？
どこにも突破口を見いだせずにすぐ諦めてしまいそうになる.

だが投げ出す前に少し落ち着いて考えてみよう. 
「\ruby{擬}{モック}テータ関数」というRamanujanの命名は意味ありげである. 
このように名付けたからにはRamanujanはテータ関数に類似した性質を期待していたのだろう. 
しかしながら, 古典的なテータ関数は正整数$ r $と正定値対称行列$ S \in \GL_r(\R) $に対して
\[
\theta_S (\tau) :=
\sum_{n \in \Z^r} q^{{}^t\!n S n/2}, \quad
q := e^{2\pi\iu\tau}
\]
と定義されるもので, Ramanujanの\ruby{擬}{モック}テータ関数とは似ても似つかない. 
果たして本当に類似した性質など期待できるだろうか？

だが「それでも何かありそうだ」と思わせるのがRamanujanである. 
もし仮に通常のテータ関数と\ruby{擬}{モック}テータ関数の間に類似した性質があるとすれば, それは何だろうか？

安直に思いつくのはテータ関数のモジュラー変換則である. 

\begin{prop}[テータ関数のモジュラー変換則, {\cite[命題2.5.1]{高瀬}}]
	\label{prop:theta_modular_trans}
	\[
%	\theta_S (\tau + 1) = \theta_S (\tau), \quad
	\theta_S \left( -\frac{1}{\tau} \right) =
	\sqrt{\det S} \sqrt{-\iu \tau}^r \theta_S (\tau).
	\]
\end{prop}

この性質は非常に重要である. 
例えば最も簡単な$ r = 1, S = 1 $の場合にこの性質を用いることでRiemannゼータ関数の関数等式を得ることができる. 
またこの性質はテータ関数がモジュラー形式をなすことを意味しており, モジュラー形式の理論を応用することで様々な数論的帰結を得ることが可能である. 

そこで\textbf{\ruby{擬}{モック}テータ関数に対してもモジュラー変換則が満たされること}を期待してみたくなる. 
だがそれはいくら何でも楽観的過ぎるだろうか？

状況証拠はRamanujanの手紙に既に記されていた. 
Ramanujanは
\begin{itemize}
	\item \ruby{擬}{モック}テータ関数たちが非自明な関係式を満たすこと
	\item \ruby{擬}{モック}テータ関数のFourier係数の漸近的性質
\end{itemize}
を発見していたが, これらは共にモジュラー形式が持つ性質である. 
この期待を単に楽観的と片付けるのは勿体無さそうだ. 

状況証拠は\ruby{擬}{モック}テータ関数の研究が進むにつれて更に集まり始めた. 
例えばWatson~\cite[pp. 78]{Watson}は位数$ 3 $の\ruby{擬}{モック}テータ関数に対してモジュラー変換則を記述することに成功している. 
それは通常のテータ関数のような単純な形ではなく誤差項を含んでおり, 非常に驚くべき式ではあるものの「確かに記述できるのは分かったけどこれで理解できたとは思えないなあ」と筆者には感じられる式である. 
Watsonの証明には拡張性に乏しく全ての\ruby{擬}{モック}テータ関数に適用することが難しいという問題もあった（彼の方法は\ruby{擬}{モック}テータ関数の「Appell--Lerch型和」と呼ばれる表示式に基づく巧妙なものである）. 

更にその後, AndrewsやHickersonが\ruby{擬}{モック}テータ関数の「Hecke型表示」を発見した. 
それは例えば次のような表示式である. 

\begin{thm}[Andrews~{\cite[Equation (1.4)]{Andrews_5_7}}]
	\[
	f_0 (q) = \frac{1}{(q)_\infty}
	\sum_{n \ge 0} \sum_{-n \le j \le n} (-1)^j q^{(5n^2 - 2j^2 + n)/2} (1 - q^{4n+2}).
	\]
	ただし$ (q)_\infty := \prod_{n=1}^{\infty} (1 - q^n) $.
\end{thm}

この表示式で着目したいのが$ q $の肩に二次形式が乗っていることである. 
となると思い起こされるのはいつものテータ関数である. 
この見方は上の表示式を少し整えることで一層明白になる. 

\begin{cor} \label{cor:mock_indefinite}
	\[
	f_0 (q) = \frac{1}{(q)_\infty}
	\sum_{n, j \in \Z} \left( \sgn(j+n) - \sgn(j-n) \right) (-1)^j q^{(5n^2 - 2j^2 + n)/2}.
	\]	
	ただし実数$ x $に対し
	\begin{align}
		\sgn(x) &:= 
		\begin{cases}
			1 & x \ge 0, \\
			-1 & x < 0
		\end{cases}
	\end{align}
	と定める. 
\end{cor}

ここで符号などの不思議な項が現れているがそれは一旦置いておいて, $ q $の肩に乗っている二次形式への注目を続けよう. 
現れているのは$ 5n^2 - 2j^2 $という不定値の二次形式である. 
つまり右辺には\textbf{不定値テータ関数}と呼ぶべき対象が現れているのだ！
ここまで来ると\ruby{擬}{モック}テータ関数をテータ関数の類似物だとみなすことに確信が持ててくるだろう. 
そして
\begin{quote}
	\centering
	\ruby{擬}{モック}テータ関数はモジュラー変換則を持つか？
\end{quote}
という疑問は今や
\begin{quote}
	\centering
	不定値テータ関数はモジュラー変換則を持つか？
\end{quote}
という問いに変わったのである！

そこで次節以降ではこの二番目の問いについて考察していこう. 

% --------------------------------------------------------------------------

\subsection{補足: $ q $級数のEuler型表示式} \label{subsec:Eulerian_form}

% --------------------------------------------------------------------------

前項でRamanujanの\ruby{擬}{モック}テータ関数に対して「このような関数は見たことが無い」と書いたが, 実際にはこのようなタイプの無限和は$ q $級数の研究においてはRamanujan以前から現れており, 現在では「Euler型表示式 (Eulerian form)」と呼ばれている
\footnote{この用語はRamanujanによるもの（\cite[119ページ]{魅惑}）であり, 恐らく\cref{thm:Jacobi}に由来する. 
	\cref{thm:Jacobi}はEulerによるものと述べられることが多いが, Andrews~\cite{Andrews_combi}によるとJacobiの仕事が初出だそうである
	（以上の歴史的背景は松坂俊輝氏に教わった）. 
	そのような理由から私にはあまり良い用語だとは思えない. }. 
本項ではその例を紹介する. 
なお本項の内容はZwegersの不定値テータ関数の解説とは直接関係しないので, そちらを優先したい方は読み飛ばして頂いて構わない. 

まずは$ q $級数の研究で頻出するPochhammer記号を準備しておこう. 

\begin{dfn}[Pochhammer記号]
	複素数$ a $と$ n \in \Z_{\ge 0} \cup \{ \infty \} $に対し
	\[
	(a; q)_n = (a)_n :=
	\begin{cases}
		1 & n=0, \\
		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) & n \in \Z_{>0}, \\
		(1 - a) (1 - aq) \cdots (1 - aq^{n-1}) \cdots & n = \infty
	\end{cases}
	\]
	と書く. 
\end{dfn}

それでは\ruby{擬}{モック}テータ関数に類する表示式を紹介しよう. 
まずは$ q $級数の中で最も古い歴史を持つ, 分割数の母関数から始める. 

\begin{thm}[Jacobi, {\cite[式 (8.2)]{整数の分割}}]
	\label{thm:Jacobi}
	\[
	\frac{1}{(q)_\infty} = \sum_{n=0}^{\infty} \frac{q^{n^2}}{(q)_n^2}.
	\]
\end{thm}

続けて紹介するのはRogers--Ramanujan恒等式と呼ばれる二つの等式である. 

\begin{thm}[Rogers--Ramanujan恒等式, {\cite[8.4節]{整数の分割}}]
	\begin{align}
		\frac{1}{(q; q^5)_\infty (q^4; q^5)_\infty} 
		&=
		\sum_{n=0}^{\infty} \frac{q^{n^2}}{(q)_n},
		\\
		\frac{1}{(q^2; q^5)_\infty (q^3; q^5)_\infty} 
		&=
		\sum_{n=0}^{\infty} \frac{q^{n^2 + n}}{(q)_n}.
	\end{align}
\end{thm}

この恒等式はこのように何気なく紹介されるとつい読み飛ばしてしまいそうになるが, 実際には深く考察すればするほど奥深い非常に重要な定理であり, 近年では丸一冊掛けてこの恒等式について解説する書籍が出版されたほどである（\cite{魅惑}）. 

Euler型表示式はRamanujan以前のRogersの仕事にも表れている. 

\begin{thm}[{Rogers~\cite[pp.~333, Equation (6)]{Rogers}, \cite[240ページ, 式 (A.200)]{魅惑}}]
	\begin{align}	
		\sum_{n \in \Z} \sgn(n) q^{(3n^2 + n)/2}
		=
		\sum_{n=0}^{\infty} \frac{(-1)^n q^{n^2 + n}}{(-q)_n}.
	\end{align}
	ただしここで\cref{cor:mock_indefinite}と同様に$ \sgn(0) := 1 $と定義していることに注意する. 
\end{thm}

この定理の左辺に現れる無限級数をRogersは\ruby{偽}{フォルス}テータ関数と呼んでいる. 
正定値二次形式が$ q $の指数に現れながら符号も現れているのが特徴である. 

Ramanujanはこれらの結果に知悉しており, 非常に多くの変種を発見している. 
\ruby{擬}{モック}テータ関数の発見にはそのような知的土壌があったものと推察される. 

またこれら$ q $級数の研究からは, Ramanujanの\ruby{擬}{モック}テータ関数を研究するには\textbf{まず$ q $級数として取り扱う}ことで取り回しの良い表示式を得ることが出発点になると考えられるだろう. 
AndrewsやHickersonによって与えられた\ruby{擬}{モック}テータ関数の不定値テータ関数表示は正にそのような取り回しの良い, つまりモジュラー形式論的な扱いがやりやすい表示式なのである. 
そしてそのような表示式が既に得られている現在では, Ramanujanによって与えられたEuler型表示式としての定義は最早忘れてしまい, 不定値テータ関数を新たな興味の対象として研究していく方針が取れる. 
前項の最後に述べたのはまさにこのような方針である. 

しかしながら疑問も残る. 
本当に\ruby{擬}{モック}テータ関数の$ q $級数的側面を忘れてしまっても良いのだろうか？
本項で紹介した種々の公式はどれも非常に非自明で意味ありげであり, 進路こそ見えないものの研究の余地は大いに残されているように思われる. 
Zwegersによって\ruby{擬}{モック}テータ関数のモジュラー形式としての側面が解き明かされた今, 次に研究すべきは$ q $級数としての側面であると私は感じている. 

\begin{rem}
	Rogers--Ramanujan恒等式やRogersによる\ruby{偽}{フォルス}テータ関数の恒等式の変種は非常に多数発見されており, \cite[付録A]{魅惑}には計236個の変種が記載されている. 
	それら恒等式はどれも美しく, 非常に重要なものであるように思われるが, 一方で背景に潜む構造が判然としない散発的な等式群という印象も与えうる. 
	実際, それらの恒等式を証明するための強力な方法として\textbf{Bailey対 (Baliey pair)}という$ q $級数の手法があるが, これは発見的な方法であり, 背景にどのような構造が潜んでいるのかは説明できていないように思われる. 
	
	そのような問題点は「Euler型表示式」という用語にも潜んでいる. 
	この用語は数学的な定義が無くRamanujanの用法を参考に各々の数学者が各々の基準で用いているため, 「Euler型表示式である／ない」の判別が非常に曖昧なのである. 
	安直に考えればRogers--Ramanujan型の恒等式に登場する無限和は「Euler型表示式」と呼んで良いように思われるが, それら恒等式は後の時代に発見されたものになるほど非常に複雑な形をしており, 果たしてそもそも本当に「Rogers--Ramanujan型の恒等式」と呼んで良いものなのか段々分からなくなってくるのである. 
	このような問題はひとえにRogers--Ramanujan型の恒等式や\ruby{偽}{フォルス}テータ関数の恒等式の背景に潜む構造が未解明であることに起因していると思われる. 
	「Euler型表示式」がどのように数学的に定式化されるかは非常に意義深い問題であると私には感じられる. 
	このようなことも上述した\ruby{擬}{モック}テータ関数の$ q $級数的側面の研究と言えるだろう. 
\end{rem}

% --------------------------------------------------------------------------

\section{不定値テータ関数のモジュラー変換則の探求} \label{sec:indefinite_theta}

% --------------------------------------------------------------------------

それでは\cref{subsec:mock}の考察で到達した「不定値テータ関数はモジュラー変換則を持つか？」という問いについて考えていこう. 
ヒントとなるのはWatson~\cite[pp. 78]{Watson}が示した位数$ 3 $の\ruby{擬}{モック}テータ関数に対するモジュラー変換則で, それは誤差項を含んでいるという特徴があった.
ここで誤差項を含むモジュラー変換則とは, $ f(\tau) $に対しある関数$ g(\tau) $が存在して
\[
f \left( -\frac{1}{\tau} \right) = f(\tau) + g(\tau)
\]
を満たすことを指している. 
尤も任意の写像$ f \colon \bbH \to \bbC $に対して$ g(\tau) := f(-1/\tau) - f(\tau) $とおけば上の等式が満たされるので, このままでは何ら数学的意味を表していない. 
重要なのはこの$ g(\tau) $が何か意味のある関数であるということであるが, この$ g(\tau) $の意味するところをWatsonの結果から類推することは難しいように思われる. 
そこでここは別のアプローチを取り, 同じように誤差項を含むモジュラー変換則を満たす関数としてどのようなものがあったかを思い出してみよう. 
典型的な例は次節で紹介する\textbf{重さ$ 2 $のEisenstein級数}$ G_2(\tau) $である. 

% --------------------------------------------------------------------------

\subsection{重さ$ 2 $のEisenstein級数とモジュラー補完という考え方} \label{subsec:modular_completion}

% --------------------------------------------------------------------------

それでは重さ$ 2 $のEisenstein級数について紹介しよう. 
まず通常のEisenstein級数は次のように定義されていたことに注意する. 

\begin{dfn}
	$ 4 $以上の偶数$ k $に対し
	\[
	G_k (\tau) := \sum_{(m, n) \in \Z^2 \smallsetminus \{ (0, 0) \}} \frac{1}{(m\tau + n)^k}
	\]
	を\textbf{重さ$ k $のEisenstein級数}と呼ぶ. 
\end{dfn}

ここで$ k \ge 4 $という仮定は絶対収束性のために必要で, $ k $が偶数であるという仮定は無限和が$ 0 $にならないために必要である. 
しかしながら重さが$ k=2 $の場合にもEisenstein級数を以下のようにして定義することができる. 

\begin{dfn}
	\[
	G_2 (\tau) := 
	\sum_{n \in \Z \smallsetminus \{ 0 \}} \frac{1}{n^2} 
	+ \sum_{m \in \Z \smallsetminus \{ 0 \}} \sum_{n \in \Z} \frac{1}{(m\tau + n)^2}
	\]
	を\textbf{重さ$ 2 $のEisenstein級数}と呼ぶ. 
\end{dfn}

つまり, 二重和では絶対収束性が成り立たないので二つの一重和に分けるのである. 
このように定義すると$ G_2 (\tau) $は$ k \ge 4 $に対する$ G_k (\tau) $と全く同様のFourier展開を持つことが分かり, $ G_k (\tau) $の自然な拡張だとみなされる. 
しかしながら$ G_2 (\tau) $はモジュラー変換則を満たさない. 
これは$ k \ge 4 $に対する$ G_k (\tau) $がモジュラー変換則$ G_k (-1/\tau) = \tau^k G_k(\tau) $を満たすことは二重和の絶対収束性から従うのに対し, $ G_2 (\tau) $は二重和で定義されていないことに起因している. 
しかしながら$ G_2 (\tau) $は誤差項を含むモジュラー変換則を満たすことが知られている. 
それが次の公式である. 

\begin{prop}[{\cite[pp.~14, Equation (1.4)]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}}]
	\label{prop:G_2}
	\[
	G_2 \left( -\frac{1}{\tau} \right) = \tau^2 G_2(\tau) - 2\pi \iu \tau.
	\]
\end{prop}

\begin{rem}
	この公式はDedekindエータ関数
	\[
	\eta(\tau) := e^{2\pi\iu\tau/24}
	\prod_{n=1}^{\infty} (1-q^n)
	\]
	のモジュラー変換則
	\[
	\eta \left( -\frac{1}{\tau} \right)
	=
	\sqrt{-\iu \tau} \eta (\tau)
	\]
	と同値であることが
	\[
	\frac{d}{d\tau} \log \eta(\tau)
	=
	\frac{\iu}{4\pi} G_2(\tau)
	\]
	から従う（\cite[Proposition 1.2.5]{DS}）. 
	$ G_2 (\tau) $の変換公式よりもこちらのDedekindエータ関数のモジュラー変換則や, それから従うRamanujanのデルタ関数
	\[
	\Delta(\tau) := q \prod_{n=1}^{\infty} (1-q^n)^{24}
	= \eta(\tau)^{24}
	\]
	のモジュラー変換則$ \Delta(-1/\tau) = \tau^{12} \Delta(\tau) $の方に見覚えがある方もいるかもしれない. 
\end{rem}

実は少し工夫すると\cref{prop:G_2}は次のように言い換えられる. 

\begin{prop}[{\cite[Exercise 1.2.8(d)]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}の証明中, \cite[Lemma 6.2]{BFOR}}]
	\label{prop:G_2_completion}
	\[
	\widehat{G}_2 (\tau) := G_2(\tau) - \frac{\pi }{\Im (\tau)}
	\]
	とおくと$ \widehat{G}_2 (-1/\tau) = \tau^2 \widehat{G}_2 (\tau) $が成り立つ.
\end{prop}

この$ \widehat{G}_2 (\tau) $は\textbf{重さ$ 2 $の非正則Eisenstein級数 (nonholomorphic Eisenstein series of weight $ 2 $)}と呼ばれている. 
\cref{prop:G_2_completion}の証明は$ \pi / \Im (\tau) $が$ G_2(\tau) $と同じ変換則を満たすことから従う. 

この$ \widehat{G}_2 (\tau) $のように, 誤差項付きモジュラー変換則を満たす関数に適切な補正関数を加えることで完全なモジュラー変換則を満たすようにする方法は現在では\textbf{モジュラー補完 (modular completion)}と呼ばれている. 
この方法のメリットとしては, $ G_2(\tau) $が満たす変換則の本質のようなものを見抜いているように見えることや, $ \tau \mapsto -1/\tau $という変換以外の一般の$ \SL_2(\Z) $に対する変換も直ちに記述できることが挙げられる. 

そこで以下では, \cref{subsec:mock}の最後に挙げた
\begin{quote}
	\centering
	不定値テータ関数はモジュラー変換則を持つか？
\end{quote}
という問いから一歩先に進んで
\begin{quote}
	\centering
	不定値テータ関数をモジュラー補完できるか？
	
	すなわち, 不定値テータ関数に補正関数を加えることで完全なモジュラー変換則を満たすようにできるか？
\end{quote}
という問いを考察していこう. 

\begin{rem} \label{rem:Hecke_trick}
	\cref{prop:G_2_completion}でいきなり登場した$ \widehat{G}_2 (\tau) $を一体どのように見つけたのだろうかと疑問に思う方もいるだろう. 
	一つの回答は「Heckeのトリック (Hecke's trick)」を用いることである. 
	これは複素変数$ s $を持つ新たな関数
	\[
	G_2 (\tau, s) := \sum_{(m, n) \in \Z^2 \smallsetminus \{ (0, 0) \}} \frac{1}{(m\tau + n)^2 \abs{m\tau + n}^{2s}}
	\]
	を考える手法である. 
	この関数は\textbf{重さ$ 2 $の実解析的Eisenstein級数 (real analytic Eisenstein series of weight $ 2 $)}と呼ばれており, 
	複素変数$ s $について$ \Re(2+2s) > 2 $の範囲で広義絶対一様収束し正則関数を定め, モジュラー変換則
	\[
	G_2 (\tau, s) = G_2 (\tau+1, s) = \tau^{2} G_2 \left( - \frac{1}{\tau}, s \right)
	\]
	を満たすことが重さ$ k \ge 4 $のEisenstein級数の場合と同様に分かる. 
	複素変数$ s $を付け加えることによって絶対収束性が担保され, モジュラー変換則が完全な形で成り立つのである. 
	そこでもしこの複素関数$ G_2 (\tau, s) $を全平面に解析接続できるなら, $ s=0 $を代入することで完全なモジュラー変換則を満たす「重さ$ 2 $のEisenstein級数のようなもの」が得られるのではないか, と期待できる. 
	この期待は実際に実現することができ, そのようにして得られる$ G_2 (\tau, 0) $はまさに$ \widehat{G}_2 (\tau) $に一致するのである！
	（詳細は\cite[Theorem 4.10.2]{DS}, \cite[pp.~19, Proposition 6]{1-2-3}の証明中, \cite[Lemma 6.2]{BFOR}を見よ. ）
	
	このような考察によって$ \widehat{G}_2 (\tau) $は二変数複素関数$ G_2 (\tau, s) $を出自に持つということが明らかになった. 
\end{rem}

\begin{rem}
	上ではモジュラー補完のメリットとして「変換則の本質のようなものを見抜いているように見える」という曖昧な書き方をしたが, これは現代の用語を用いて正確に書くと
	\begin{quote}
		\centering
		$ \widehat{G}_2 (\tau) $は\textbf{重さ$ 2 $の調和Maass形式}であり, 
		$ G_2 (\tau) $はその\textbf{正則部分}である. 
		
		従って$ G_2 (\tau) $は\textbf{重さ$ 2 $の\ruby{擬}{モック}モジュラー形式}である
	\end{quote}
	という主張に言い換えられる（ここで「調和Maass形式 (harmonic Maass form of weight $ 2 $)」, 「正則部分 (holomorphic part)」, 「\ruby{擬}{モック}モジュラー形式 (mock modular form of weight $ 2 $)」の定義はそれぞれ\cite[Definition 4.2, Definition 4.4, Definition 5.16 i)]{BFOR}を見よ）. 
	
	つまり$ G_2 (\tau) $の「変換則の本質のようなもの」は「\ruby{擬}{モック}モジュラー形式」として定式化されるのである. 
	不定値テータ関数に対してもこのような見方を与えたいというのがモジュラー補完を考える意義である. 
	
	なお, 実際には\ruby{擬}{モック}モジュラー形式はZwegersによる不定値テータ関数のモジュラー補完の仕事を契機に定式化された概念である. 
	これは見方を変えれば, Zwegersによる不定値テータ関数のモジュラー補完は「\ruby{擬}{モック}モジュラー形式」という新概念の発見に繋がるほどの大発見だったということである. 
	Zwegersの仕事は言ってしまえば「特殊関数の発見」である. 
	しかしながらその発見は\ruby{擬}{モック}モジュラー形式の理論を展開する契機を与えた, とてもとても重要なものである. 
	
	数学の方向性として, Grothendieckによるスキーム論の構築に代表される, 舞台を理論的に自然な方向へと整備していきトップダウン方式で古典的問題を解決する方向があるように私には感じられる. 
	Zwegersの研究はそうではなく, 不定値テータ関数というたった一つの卵が孵化するまでひたすら温める方向である（このような研究方針はZwegersに限らずモジュラー形式の研究者全般にわたる傾向であるように思われる）. 
	両者は全く別物であるが, どちらも同じくらい重要な方向性であると私は考えている（駆け出しの若輩者が生意気言ってごめんなさい）. 
\end{rem}


% --------------------------------------------------------------------------

\subsection{不定値テータ関数の収束性} \label{subsec:indefinite_theta_convergency}

% --------------------------------------------------------------------------

それでは不定値テータ関数のモジュラー補完について考えていきたいところだが, その前に一度不定値テータ関数の定義を振り返っておこう. 

まずは一番簡単な不定値二次形式として$ m^2 - n^2 $に対して, その不定値テータ関数をどのように定義すれば良いか考えていこう. 
安直に思い付く
\[
\sum_{(m, n) \in \Z^2} q^{(m^2 - n^2)/2}
\]
はうまくいかない%
\footnote{ここで$ q $の肩に乗せた二次形式を$ 1/2 $倍している理由は, 通常のテータ関数でも$ 1/2 $倍したものを定義に採用するとモジュラー変換則が綺麗に書けることに倣ったためである. 定義の本質的な部分ではないので気にしなくて良い. }. 
なぜなら$ m^2 - n^2 = 0 $となる$ (m, n) \in \Z^2 $は無数に存在するので定数項が収束しないし, また今$ \abs{q} < 1 $なのに$ m^2 - n^2 $はいくらでも小さな負の数を取りうるためである. 
ではどのようにして「不定値二次形式$ m^2 - n^2 $のテータ関数」を定義すれば良いのだろうか. 

ヒントはAndrewsによる\ruby{擬}{モック}テータ関数のHecke型表示から見出せる. 
Andrewsの結果を整理した表示式である\cref{cor:mock_indefinite}には
\[
\sum_{n, j \in \Z} \left( \sgn(j+n) - \sgn(j-n) \right) (-1)^j q^{(5n^2 - 2j^2 + n)/2}
\]
という式が現れていた. 
\cref{subsec:mock}でこの定理を紹介したときには「符号が現れているが一旦置いておく」と述べたが, 今こそ符号に着目すべき時である. 
この式は当然収束する（でなければこの式は意味を持たない）が, 実はこの符号こそが収束性を担保しているのである. 
実際, 上の式で符号の差が消滅する部分を除いて書くと
\[
\left( \sum_{\substack{n, j \in \Z, \\ j+n > 0 > j-n}} - \sum_{\substack{n, j \in \Z, \\ j+n < 0 < j-n}} \right) (-1)^j q^{(5n^2 - 2j^2 + n)/2}
\]
と変形できるが, この和の範囲では$ q $の肩に乗っている二次形式$ 5n^2 - 2j^2 $がどんどん大きな値を取ることが見て取れる. 
つまり符号の差が消滅する部分というのはまさに収束性が悪い部分であり, 符号の差を付け加えた結果として収束性が従うのである. 

この例は係数が少し複雑なので, 先ほどの$ m^2 - n^2 $という二次形式の場合に説明し直してみる. 
$ m^2 - n^2 $が正となるのは$ \abs{m} > \abs{n} $のとき, すなわち$ n+m > 0 > n-m $または$ n+m < 0 < n-m $のときなので, 不定値テータ関数の定義として
\begin{align}
	&\left( \sum_{\substack{n, j \in \Z, \\ n+m > 0 > n-m}} - \sum_{\substack{n, j \in \Z, \\ n+m < 0 < n-m}} \right) q^{(m^2 - n^2)/2}
	\\
	= \,
	&\sum_{(m, n) \in \Z^2} \left( \sgn(n+m) - \sgn(n-m) \right) q^{(m^2 - n^2)/2}
	\label{eq:indef_ex}
\end{align}
を採用すれば良さそうである. 
このように定義した無限級数は実際に収束するので, これを「不定値テータ関数」と呼んでしまって問題ないと了承できる. 

以上から不定値テータ関数は符号を用いて定義できることが分かった. 

\begin{rem} \label{rem:indef_ambiguity}
	上では$ m^2 - n^2 $が正となるための必要十分条件を考えているが, 実際には十分条件さえ与えてしまえば同様に「不定値テータ関数」を定義できる. 
	例えば$ \abs{m} > 2\abs{n} $のときも$ m^2 - n^2 $は正となるので
	\[
	\sum_{(m, n) \in \Z^2} \left( \sgn(2n+m) - \sgn(2n-m) \right) q^{(m^2 - n^2)/2}
	\]
	も収束する. 
	これも「不定値テータ関数」と呼んでしまって差し支えないだろう. 
	
	このように不定値テータ関数の定義には和の範囲を制限するための自由度がある. 
	詳細は\cref{sec:Zwegers_theta}で述べるが, この自由度はZwegersの記号ではベクトル$ c_1, c_2 $の取り方に対応している. 
\end{rem}


% --------------------------------------------------------------------------

\subsection{不定値テータ関数のモジュラー補完の探求} \label{subsec:modular_completion}

% --------------------------------------------------------------------------

それでは
\begin{quote}
	\centering
	不定値テータ関数をモジュラー補完できるか？
	
	すなわち, 不定値テータ関数に補正関数を加えることで完全なモジュラー変換則を満たすようにできるか？
\end{quote}
という問いを考察していこう. 
この問いに答えるには, たった一個の補正関数を見つけることさえできれば良い. 
だがどのようにして探せば良いだろうか？

重さ$ 2 $のEisenstein級数の場合は, 変数を増やして解析接続したのち特殊化するというHeckeのトリックが有効だった（\cref{rem:Hecke_trick}）. 
だが不定値テータ関数の場合にはそのような上手い変数の増やし方は思い付かない. 
何か別な方法を考えよう. 

そこで, そもそも通常のテータ関数のモジュラー変換則（\cref{prop:theta_modular_trans}）がどのように証明されたかに立ち返ってみよう. 
証明のポイントはGauss関数$ e^{-\pi x^2} $がFourier変換で不変という性質を持っていることである. 
この性質を利用することで固定した$ t > 0 $に対し$ f_t (x) := e^{-\pi t x^2} $のFourier変換が$ \sqrt{t} e^{-\pi  x^2/t} $になることが分かり, Poissonの和公式を用いることで$ \theta (\tau) := \sum_{n \in \Z} q^{n^2/2} $のモジュラー変換則$ \theta (t\iu) = \sqrt{t} \theta (-1/t\iu) $が従うのである. 

そこで不定値テータ関数に対してもFourier変換で不変な関数をうまく見つけられれば同様にモジュラー変換則が成り立つ関数（すなわちモジュラー補完）を見つけられることになる. 
前項での観察から$ r $変数不定値二次形式のテータ関数は一般に
\[
\sum_{n \in \Z^r} \left( \sgn(\text{$ 1 $次形式}) - \sgn(\text{$ 1 $次形式}) \right) q^{\text{不定値$ 2 $次形式}}
\]
の形で定義できると推察されるので, ここでは不定値テータ関数のモジュラー補完として
\[
\sum_{n \in \Z^r} \rho(n) q^{\text{不定値$ 2 $次形式}}
\]
という形のものを探索してみることにしよう. 
ただしここで$ \rho(x) $は何らかの意味で上式の符号の項を復元するような$ \R^r $上の実解析的関数で, $ \rho(x) e^{-\pi (\text{不定値$ 2 $次形式})} $がFourier変換で不変になるようなもの（あるいは, そこまで言わなくてもFourier変換が元の$ \rho(x) e^{-\pi (\text{不定値$ 2 $次形式})} $に近い式になるもの）である. 

話を簡単にするために$ \rho(x) $は一変数関数として, 何らかの意味で符号関数$ \sgn(x) $を復元し, $ \rho(x) e^{-\pi x^2} $のFourier変換が自身と近い式になるものを探すことにする（このような設定下では二次形式の不定値性は意味をなさなくなるが, 今は気にせず後で考えることにする）. 
ここで「何らかの意味で$ \sgn(x) $を復元する」というのは非常に曖昧な言葉遣いだが, 思い切って「$ \sgn(x) $を滑らかに補完する」と解釈してみる. 
符号関数$ \sgn(x) $は原点で不連続な階段状の関数だが, 段差を滑らかに繋いだ関数として$ \rho(x) $を見つけてこようというわけである. 
そのような特徴を持つ関数は一般に「シグモイド曲線」と呼ばれており
\footnote{グラフの形がギリシャ文字のシグマ$ \sigma $の異体字$ \varsigma $に似ていることに由来する. }, 
候補として色々な関数がある. 
例えば$ \arctan(x) $や$ \tanh(x) $がそれである. 
それら関数$ f(x) $に対して一つずつ$ f(x) e^{-\pi x^2} $のFourier変換を計算し, 自身と近い式になる$ f(x) $が見つかればそれが探していた$ \rho(x) $である. 

つまり「Fourier変換が近い式になる」という「ガラスの靴」に合うような「シンデレラ」こと$ \rho(x) $を探すことが目標である. 
Zwegersがどのようにしてシンデレラを見つけたのか私は知らないが, 一つ考えられるやり方は上に書いたように王子様よろしく一人一人のシグモイド曲線に対してガラスの靴を履いてもらう方法である. 
だがここでは私なりのシンデレラの探し方を紹介してみよう. 
それはガラスの靴を一生懸命眺めてみて持ち主がどんな人物なのかを推測する方法である
\footnote{こちらの方がより数学者らしい方法と言えるかもしれない. 王子様が数学者だったらガラスの靴からシンデレラをプロファイリングして探しただろうか？}. 

それではガラスの靴を詳しく見ていこう. 
まずはともあれ$ f(x) e^{-\pi x^2} $のFourier変換を計算することが先決だ. 
記号の確認のためにFourier変換の定義と諸性質を振り返っておこう. 

\begin{dfn}
	急減少関数$ f \colon \R \to \bbC $に対し, そのFourier変換を
	\[
	\widehat{f}(x) := \int_{-\infty}^{\infty} f(y) e^{-2\pi\iu xy} dy
	\]
	で定める. 
\end{dfn}

\begin{nota}
	Gauss関数を$ g(x) := e^{-\pi x^2} $で定める. 
\end{nota}

\begin{lem} \label{lem:Fourier}
	急減少関数$ f, h \colon \R \to \bbC $とGauss関数$ g(x) := e^{-\pi x^2} $に対し次が成立する. 
	\begin{enumerate}
		\item $ \widehat{g} = g $.
		\item 実数$ a \in \R \setminus \{ 0 \} $に対し$ f_a(x) := f(ax) $とおくと
		$ \widehat{f_a}(x) = \abs{a}^{-1} f_{a^{-1}} (x) $.
		\item $ \widehat{\widehat{f}} = f_{-1} $.
		\item 急減少関数$ f $と$ h $の畳み込み積を
		\[
		f \ast h (x) := \int_{-\infty}^{\infty} f(y) h(x-y) dy
		\]
		で定めると
		\[
		\widehat{fh} = \widehat{f} \ast \widehat{h}, \quad
		\widehat{f \ast h} = \widehat{f} \widehat{h}
		\]
		 が成り立つ. 
		 \item \label{item:lem:Fourier_diff}
		 整数$ n \in \Z $に対し$ \widehat{f^{(n)}} (x) = (2 \pi \iu x)^n \widehat{f}(x) $が成り立つ. 
		 ただし負の整数$ -n \in \Z_{<0} $に対し
		 \[
		 f^{(-n)} := \left( \frac{d^{-1}}{dx^{-1}} \right)^n f, \quad
		 \frac{d^{-1} f}{dx^{-1}} (x) = f^{(-1)} (x) := \int_{0}^{x} f(y) dy
		 \]
		 とおく.
	\end{enumerate}
\end{lem}

これらの基本性質を用いるとガラスの靴について次が分かる. 

\begin{lem}
	急減少関数$ f \colon \R \to \bbC $に対し$ \widehat{fg}(x) = (f \ast g)(-\iu x) g(x)  $.
\end{lem}

\begin{proof}
	\begin{align}
		&\widehat{fg}(x) 
		=
		(\widehat{f} \ast \widehat{g}) (x)
		=
		(\widehat{f} \ast g) (x)
		=
		\int_{-\infty}^{\infty} \widehat{f} (y) g(x-y) dy
		=
		\int_{-\infty}^{\infty} \widehat{f} (y) e^{-\pi (x-y)^2} dy
		\\
		= \,
		&g(x) \int_{-\infty}^{\infty} \widehat{f} (y) g(y) e^{2\pi xy} dy
		=
		g(x) \widehat{(\widehat{f} g)} (x \iu)
		=
		g(x) ( \widehat{\widehat{f}} \ast \widehat{g}) (x \iu)
		\\
		= \,
		&g(x) ( f_{-1} \ast g) (x \iu)
		=
		g(x) ( f \ast g_{-1}) (-x \iu)
		=
		g(x) ( f \ast g) (-x \iu).
	\end{align}
	ただし最後から二番目の等式変形では畳み込み積の性質$ f_{-1} \ast h =  (f \ast h_{-1})_{-1} $を用いた. 
\end{proof}

この補題から$ (f \ast g)(-\iu x) $が$ f(x) $に近い式になるような$ f $こそがシンデレラであることが分かる. 
ここで「近い式」というのは曖昧な表現だが, 思い切って「$ (f \ast g)(x) $が$ f(x) $に近い式」と言い換えてしまうことにしよう. 
この条件は畳み込み積が現れており扱いにくいので, Fourier変換することで「$ \widehat{f} g $が$ \widehat{f} $に近い式」という$ \widehat{f} $に関するかなり分かりやすい条件に言い換え, 代わりにこちらを詳しく見ていくことにしよう. 
まず単に$ \widehat{f} g = \widehat{f} $という条件を考えると$ \widehat{f} = 0 $となってしまい意味をなさない. 
そこで「近い式」の意味をうまく汲み取りつつ$ \widehat{f} $を探す必要がある. 
ここは気合と直感が要求される部分である. 
シンデレラを探すのに安楽椅子探偵では役不足で, やはりどこかで自分の足を動かして頑張る必要があるということなのだろう. 
\footnote{ここの「役不足」は本来的には誤用であり「力不足」と書くのが本来は正しいが, 「役不足」と書いても伝わるし座りが良いように思う. }

さて, 頑張ってそのような$ \widehat{f} $を探してみると, 例えば$ \widehat{f} = g $とおくと
$ \widehat{f} g (x) = g^2 (x) = g(\sqrt{2} x) = \widehat{f} (\sqrt{2} x) $
が分かる. 
これは「近い式」と言ってしまって良いだろう. 
だが$ \widehat{f} = g $すなわち$ f = g $が探していたシンデレラかというと, そうではない. 
$ g $はシグモイド曲線でないためである. 
そもそも上では何も考えずに$ f $のFourier変換$ \widehat{f} $を考えていたが, 今$ f $はシグモイド曲線で急減少関数ではない（$ 2 $乗可積分関数でもない）ためFourier変換は定義できないのである. 

だが諦めてはいけない. 
関数方程式の解を見つける有効な方法として, その方程式がどのような対称性を持つか考察するという方法がある. 
ここで「対称性」と言っているのは何らかの群が解空間に作用するかということを指しており, これは平たく言ってしまえば一つ解が与えられたときにそこから新しい解を作る方法があるかということである. 
今考えている元々の関数方程式は「$ f \ast g $が$ f $に近い」で, その解として$ f = g $があるということが分かっている（実際には今は曖昧な状況を考えているので「関数方程式」や「解」という数学用語を使うのは相応しくないが, 簡単のためにこう書くことにする）. 

さて, この関数方程式はどのような対称性を持つだろうか？
ここも気合と直感が要求される部分だが, 頑張って探すと$ f $が解ならその微分$ f' $も解であることに気付けるかもしれない（これは畳み込み積の性質
$ (f \ast h)' = f \ast h' $から分かる）. 
すると同様の議論から任意の正整数$ n \in \Z_{>0} $に対して$ f^{(n)} $も解になることが分かる. 
これは群作用にはなっていない. $ \Z_{>0} $が加法について逆元を持たないためである. 
だが$ n < 0 $のときにも\cref{lem:Fourier} \cref{item:lem:Fourier_diff}のように$ f^{(n)} $を定義することで, $ n < 0 $でも$ f^{(n)} $が解になり, 考えている関数方程式に群$ \Z $が作用することが分かるのである. 

さて, 以上のことから任意の$ n \in \Z $に対し$ f = g^{(n)} $が関数方程式の解であることが分かった. 
そこで$ g^{(n)} $がシグモイド曲線となるような整数$ n \in \Z $が存在するかを考えてみよう. 
$ n>0 $のときは$ g^{(n)} $は$ g $と同様に急減少関数となるので候補から除外する. 
となると考えるべきは$ n < 0 $のときだが, 実はなんと$ g^{(-1)} $はシグモイド曲線になるのである！
実際, \textbf{誤差関数}
\[
\erf(x) := \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt
\]
というシグモイド曲線について$ g^{(-1)} (x) = 2^{-1} \erf(\sqrt{\pi} x) $が成り立つ！

このようにして, 探し求めていたシンデレラは誤差関数$ \erf(x) $だったことが判明した！
ここからは仕上げ作業として元の不定値テータ関数の設定に戻り, きちんとモジュラー変換則が成り立つように係数を調整する必要があるが, そのような作業はシンデレラが見つかった今では似合うドレスを仕立てるようなもので, 真面目に取り組めば必ずできることである. 

それではいよいよ次節ではZwegersによる不定値テータ関数のモジュラー補完の定義を述べていこう. 



% --------------------------------------------------------------------------

\subsection{余談: Heckeの不定値テータ関数} \label{subsec:Hecke_theta}

% --------------------------------------------------------------------------

\cref{subsec:indefinite_theta_convergency}では不定値テータ関数の定義として符号の差を加えた定義を採用した. 
これはAndrewsによる\ruby{擬}{モック}テータ関数のHecke型表示に着想を得たものだったが, そうでない文脈から不定値テータ関数の定義を探求する方針もある. 
それが\textbf{Heckeの不定値テータ関数}である. 

そこで本項ではこのHeckeの不定値テータ関数を簡単に紹介する. 
本項の内容はZwegersの不定値テータ関数の解説とは直接関係しないので, そちらを優先したい方は読み飛ばして頂いて構わない. 

Heckeによる不定値テータ関数の定義の発想は, 虚二次体に対して定まる正定値二元二次形式からテータ関数が定まるように, 実二次体に対して定まる不定値二元二次形式から何らかのテータ関数を定義できないかというアイデアに基づくように思われる. 

Heckeの不定値テータ関数は以下のように定義される. 

\begin{dfn}[{Hecke~\cite{Hecke}}]
	不定値二元二次形式$ Q \colon \Z^2 \to \Z $のHeckeテータ関数を
	\begin{align}
		\vartheta_Q (\tau) 
		&:=
		\sum_{l = (m, n) \in \Z^2 / \SL_2(\Z)_Q, \, Q(l) > 0} \sgn_0(m) q^{Q(l)}, 
		\\
		\vartheta_Q^* (\tau)
		&:=
		\sum_{l = (m, n) \in \Z^2 / \SL_2(\Z)_Q} \sgn_0(m) q^{\abs{Q(l)}}
	\end{align}
	で定める. 
	ただし$ \SL_2(\Z)_Q := \{ \gamma \in \SL_2(\Z) \mid Q \circ \gamma = Q \} $は固定部分群である. 
\end{dfn}

Hecke~\cite[Satz 7]{Hecke}はこのテータ関数が重さ$ 1 $のモジュラー変換則を満たすことを示している. 

定義のポイントは格子全体に亙る和ではなく固定部分群による商を考えているということである. 
実二次体のDedekindゼータ関数を考察していると確かにこのような商を考えることがあるので（例えばHeckeの積分公式）, このような定義は確かに自然である. 
しかしながら\ruby{擬}{モック}テータ関数を研究したいという我々の目的からは外れるものである. 

\begin{rem}
	実際にはHecke~\cite{Hecke}は更にパラメータを付け加えたテータ関数を定義し, そのモジュラー変換則を与えている. 
\end{rem}


% --------------------------------------------------------------------------

\section{Zwegersの不定値テータ関数} \label{sec:Zwegers_theta}

% --------------------------------------------------------------------------

これまでの議論をまとめると, 
\begin{itemize}
	\item \ruby{擬}{モック}テータ関数のモジュラー変換則を調べるには, 不定値テータ関数のモジュラー変換則を調べれば良い
	\item 不定値テータ関数のモジュラー変換則を調べるには, 不定値テータ関数のモジュラー補完を与えれば良い
	\item 不定値テータ関数のモジュラー補完を与えるには, 誤差関数$ \erf(x) $を用いれば良い
\end{itemize}
ということが分かっている. 
そこで本節ではいよいよZwegersによる不定値テータ関数の定義を与えよう. 

% --------------------------------------------------------------------------

\subsection{Zwegersの不定値テータ関数の定義} \label{subsec:Zwegers_theta_def}

% --------------------------------------------------------------------------

それではZwegersの不定値テータ関数の定義を述べていこう. 
以下の記号を固定する. 

\begin{symb}
	\begin{itemize}
		\item 正整数$ r \in \Z_{>0} $.
		\item 整数係数$ r $次対称行列$ A \in \Sym_r(\Z) $であって, 非退化で符号数$ (r-1, 1) $のもの（すなわち正の固有値が$ r-1 $個, 負の固有値が$ 1 $個のもの）.
	\end{itemize}
\end{symb}

これに対し次の記法を定めておく. 

\begin{nota}
	\begin{itemize}
		\item 不定値二次形式$ Q \colon \R^r \to \R, \, x \mapsto {}^t\!x A x /2 $.
		\item 双線形形式$ B \colon \bbC^r \times \bbC^r \to \bbC, \, (x, y) \mapsto {}^t\!x A y $.
	\end{itemize}
\end{nota}

以上のデータを基にZwegersの不定値テータ関数が定義されるが, いきなり最も一般的な状況を述べるのではなく, まずは特殊で分かりやすい場合から紹介することにする. 

\begin{dfn}
	\label{dfn:Zwegers_theta_special}
	\leavevmode %強制的な改行
	\begin{itemize}
		\item ベクトル$ c_1, c_2 \in \R^r $であって$ Q(c_1), Q(c_2), B(c_1, c_2) < 0 $なるもの,
		\item ベクトル$ a, b \in \R^r $,
		\item ベクトル$ z := a \tau + b \in \bbC^r $
	\end{itemize}
	に対し	
	\begin{align}
		&\vartheta_{a, b}^{c_1, c_2} \left( \tau \right)
		\\
		:= \,
		&\sum_{\nu \in a + \Z^r}
		\left( \erf \left( \sqrt{\pi \Im(\tau)} \frac{B(c_1, \nu)}{\sqrt{-Q(c_1)}} \right) - \erf \left( \sqrt{\pi \Im(\tau)} \frac{B(c_2, \nu)}{\sqrt{-Q(c_2)}} \right) \right)
		e^{2\pi \iu B(\nu, b)} q^{Q(\nu)},
	\end{align}
	\begin{align}
		&\vartheta_{A}^{c_1, c_2} \left( z; \tau \right)
		\\
		:= \,
		&e^{-2\pi \iu B(a, b)} q^{-Q(a)} \vartheta_{a, b}^{c_1, c_2} \left( \tau \right)
		\\
		= \,
		&\sum_{n \in \Z^r}
		\left( \erf \left( \sqrt{\pi \Im(\tau)} \frac{B(c_1, n + a)}{\sqrt{-Q(c_1)}} \right) - \erf \left( \sqrt{\pi \Im(\tau)} \frac{B(c_2, n + a)}{\sqrt{-Q(c_2)}} \right) \right)
		e^{2\pi \iu B(n, z)} q^{Q(n)}
	\end{align}
	と定義する. 
\end{dfn}

\begin{ex}
	\[
	 r = 2, \quad
	 A = \pmat{1 & 0 \\ 0 & -1}, \quad
	 a = b = \pmat{0 \\ 0}, \quad
	 c_1= \pmat{1 \\ -2}, \quad
	 c_2= \pmat{-1 \\ -2}
	\]
	のとき
	\[
	\vartheta_{a, b}^{c_1, c_2} \left( \tau \right)
	=
	\sum_{(m, n) \in \Z^2}
	\left( \erf \left( \sqrt{\pi \Im(\tau)} \frac{2n+m}{\sqrt{3}} \right) - \erf \left( \sqrt{\pi \Im(\tau)} \frac{2n-m}{\sqrt{3}} \right) \right)
	q^{(m^2 - n^2)/2}
	\]
	である. 
	これは\cref{rem:indef_ambiguity}で述べた不定値テータ関数
	\[
	\sum_{(m, n) \in \Z^2} \left( \sgn(2n+m) - \sgn(2n-m) \right) q^{(m^2 - n^2)/2}.
	\]
	のモジュラー補完である. 
\end{ex}

さて, \cref{eq:indef_ex}では
\[
\sum_{(m, n) \in \Z^2} \left( \sgn(n+m) - \sgn(n-m) \right) q^{(m^2 - n^2)/2}
\]
という不定値テータ関数を紹介した. 
ここで符号の中に現れている一次形式は
\[
n+m = B \left( \pmat{m \\ n}, c_1 \right), \quad
c_1 := \pmat{1 \\ -1}
\]
と書けているが, ここで$ Q(c_1) = 0 $なので\cref{dfn:Zwegers_theta_special}の状況から外れてしまっている. 

実はこのような場合にも不定値テータ関数のモジュラー補完が定義できるが, それは誤差関数$ \erf(x) $を用いずに符号をそのまま用いたものになっている. 
つまり, モジュラー補完を考えずとも初めから元の不定値テータ関数が完全なモジュラー変換則を満たすのである. 
これはとても奇妙なことに思われるが, \cref{dfn:Zwegers_theta_special}における状況の極限としてこのような場合が現れることによるものである. 

それでは$ Q(c_i) = 0 $の場合にも定義を拡張しよう. 

\begin{dfn}[{Zwegers~\cite[Section 2.2]{Zwegers_thesis}, \cite[Equation 8.23]{BFOR}}]
	\label{dfn:Zwegers_theta_general}
	\leavevmode %強制的な改行
	\begin{itemize}
		\item ベクトル$ c_1, c_2 \in \R^r $であって$ Q(c_1) \le 0, \, Q(c_2) \le 0, \, B(c_1, c_2) < 0 $を満たし, $ i = 1, 2 $に対し$ Q(c_i) = 0 $のときは$ c_i \in \Q^r $を満たすもの,
		\item ベクトル$ a \in \R^r $であって$ i = 1, 2 $に対し$ Q(c_i) = 0 $のときは$ B(c_i, a) \notin \Z $を満たすもの,
		\item ベクトル$ b \in \R^r $,
		\item ベクトル$ z := a \tau + b \in \bbC^r $
	\end{itemize}
	に対し
	\begin{align}
		\vartheta_{a, b}^{c_1, c_2} \left( \tau \right)
		:= \,
		&\sum_{\nu \in a + \Z^r}
		\left( \rho^{c_1} (\nu, \tau) - \rho^{c_2} (\nu, \tau) \right)
		e^{2\pi \iu B(\nu, b)} q^{Q(\nu)},
		\\
		\vartheta_{A}^{c_1, c_2} \left( z; \tau \right)
		:= \,
		&e^{-2\pi \iu B(a, b)} q^{-Q(a)} \vartheta_{a, b}^{c_1, c_2} \left( \tau \right)
		\\
		= \,
		&\sum_{n \in \Z^r}
		\left( \rho^{c_1} (n+a, \tau) - \rho^{c_2} (n+a, \tau) \right)
		e^{2\pi \iu B(n, z)} q^{Q(n)}
	\end{align}
	と定義する. 
	ただし
	\begin{align}
		\rho^c(\nu, \tau) 
		&:=
		\begin{dcases}
			\erf \left( \sqrt{\pi \Im(\tau)} \frac{B(c, n + a)}{\sqrt{-Q(c)}} \right) & Q(c) < 0, \\
			\sgn_0(B(c, \nu)) & Q(c) = 0,
		\end{dcases}	
		\\
		\sgn_0(x) &:= 
		\begin{cases}
			1 & x > 0, \\
			0 & x = 0, \\
			-1 & x < 0.
		\end{cases}
	\end{align}
\end{dfn}

\begin{rem}
	\cref{cor:mock_indefinite}では符号関数を$ \sgn(0) := 1 $と定義していたが, 上では$ \sgn_0(0) := 0 $という定義を採用している. 
	前者の方は$ q $級数の文脈だと扱いやすい定義で, 後者の方は誤差関数の極限と見ることによってモジュラー変換則が扱いやすい定義になっている. 
	なおZwegersの学位論文\cite{Zwegers_thesis}や\cite{BFOR}では$ \sgn(0) := 0 $という定義を採用していることに注意する. 
\end{rem}

\begin{ex}
	\[
	r = 2, \quad
	A = \pmat{1 & 0 \\ 0 & -1}, \quad
	a = b = \pmat{0 \\ 0}, \quad
	c_1= \pmat{1 \\ -1}, \quad
	c_2= \pmat{-1 \\ -1}
	\]
	のとき
	\[
	\vartheta_{a, b}^{c_1, c_2} \left( \tau \right)
	=
	\sum_{(m, n) \in \Z^2} \left( \sgn_0(n+m) - \sgn_0(n-m) \right) q^{(m^2 - n^2)/2}
	\]
	である. 
	なおこのとき$ B(c_i, a) = 0 \in \Z $なのでこの状況は\cref{dfn:Zwegers_theta_general}の条件を満たしていない. 
\end{ex}

\cref{dfn:Zwegers_theta_general}では極力新しい記号を導入せずに定義を述べたが, Zwegers~\cite{Zwegers_thesis}はもう少し記号を準備している. 
例えばベクトル$ c_1, c_2 $に関する条件は二次形式$ Q $に関する錐を用いて記述しているが, これについては\cref{subsec:cone}で紹介する. 

% --------------------------------------------------------------------------

\subsection{Zwegersの不定値テータ関数の性質} \label{subsec:Zwegers_theta_property}

% --------------------------------------------------------------------------

それではZwegersの不定値テータ関数の性質を見ていこう. 

\begin{thm}[{Zwegers~\cite[Proposition 2.4]{Zwegers_thesis}, \cite[Theorem 8.26]{BFOR}}]
	\cref{dfn:Zwegers_theta_general}の状況で$ \vartheta_{a, b}^{c_1, c_2} \left( \tau \right) $を定める無限級数は広義一様収束する. 
\end{thm}

Zwegersの不定値テータ関数が持つ最も重要な性質はモジュラー変換則を満たすことである. 
それはZwegersの学位論文以後, 現在では次のように定式化されている. 

\begin{thm}[{\cite[Theorem 8.30]{BFOR}}]
	\cref{dfn:Zwegers_theta_general}の設定下で$ c_1, c_2 \in \Z^r $であり, それらの各成分は互いに素だと仮定する. 
	このとき$ \vartheta_{A}^{c_1, c_2} \left( z; \tau \right) $は重さ$ r/2 $のベクトル値混合調和Maass形式 (vector-valued mixed harmonic Maass form) の成分となる. 
%	特に$ \vartheta_{S, \lambda, \lambda'} \left( z; \tau \right) $はある合同部分群$ \Gamma \subset \SL_2(\Z) $に関する重さ$ 1 $の混合\ruby{擬}{モック}モジュラー形式である. 
\end{thm}

ここで混合\ruby{擬}{モック}モジュラー形式は以下のように定義される概念である. 

\begin{dfn}[{\cite[Definition 13.1]{BFOR}}]
	\textbf{重さ$ k $の混合調和Maass形式}%, もしくは\textbf{深さ$ 2 $, 重さ$ k $の調和Maass形式}
	とは有限和$ f_1(\tau) g_1(\tau) + \cdots + f_n(\tau) g_n(\tau) $で表される関数であって, 各$ f_i(\tau) $は重さ$ k_i $の弱正則モジュラー形式であり各$ g_i(\tau) $は重さ$ l_i $の制御可能増大度の調和Maass形式 (harmonic Maass form of manageable growth, \cite[Definition 4.1]{BFOR}) であり各$ 1 \le i \le n $に対し$ k_i + l_i = k $を満たすもののことである. 
%	重さ$ k $の混合調和Maass形式の正則部分を\textbf{混合\ruby{擬}{モック}モジュラー形式}と呼ぶ. 
\end{dfn}

ここで「制御可能増大度の調和Maass形式」という未定義語が登場しているが, これ以上は解説しないことにする. 
定式化がどうされるにしろ, Zwegersの不定値テータ関数の定義における一番のポイントは誤差関数の導入により通常のテータ関数と同様にPoissonの和公式からモジュラー変換則が従うことである. 


% --------------------------------------------------------------------------

\subsection{不定値二次形式から定まる錐の構造} \label{subsec:cone}

% --------------------------------------------------------------------------

本項では\cref{subsec:Zwegers_theta_def}で言及を避けた二次形式$ Q $に関する錐について紹介する. 

ポイントは次の補題である. 

\begin{lem} \label{lem:cone}
	$ r $次元Euclid空間$ \R^r $の部分集合$ \{ c \in \R^r \mid Q(c) < 0 \} $の連結成分は$ 2 $つあり, それらを$ C_+, C_- $とおくと
	$ c_+, c_+' \in C_+, \, c_-, c_-' \in C_- $に対し
	\[
	B(c_+, c_+') < 0, \quad
	B(c_+, c_-) > 0, \quad
	B(c_-, c_-') < 0
	\]
	が成り立つ. 
	
	従って$ c_1, c_2 \in \{ c \in \R^r \mid Q(c) < 0 \} $が同一の連結成分に属することと$ B(c_1, c_2) < 0 $を満たすことは同値である. 
\end{lem}

\begin{proof}
	基底変換することで
	\[
	A = \pmat{ 1 & & & & \\ & \ddots & & \\ & & 1 & \\ & & & -1}
	\]
	として良い. このとき
	\begin{align}
		\{ c \in \R^r \mid Q(c) < 0 \}
		&= \{ (c_1, \dots, c_r) \in \R^r \mid c_1^2 + \cdots + c_{r-1}^2 < c_r^2 \}
		\\
		&= C_+ \sqcup C_-
	\end{align}
	と書ける. 
	ただし
	\[
	C_\pm :=  \{ (c_1, \dots, c_r) \in \R^r \mid c_1^2 + \cdots + c_{r-1}^2 < c_r^2, \, \pm c_r > 0 \}
	\]
	とおく. 
	ここで$ Q(c), Q(c') < 0 $なる$ c = (c_1, \dots, c_r), c' = (c'_1, \dots, c'_r) \in \R^r $に対しCauchy--Schwartzの不等式より
	\[
	(c_1 c'_1 + \cdots + c_{r-1} c'_{r-1})^2
	\le
	(c_1^2 + \cdots + c_{r-1}^2) ({c'_1}^2 + \cdots + {c'_{r-1}}^2)
	<
	c_r^2 {c'_r}^2
	\]
	なので
	\[
	B(c, c') = c_1 c'_1 + \cdots + c_{r-1} c'_{r-1} - c_r c'_r \neq 0
	\]
	である. 
	よって連続写像$ B \colon \R^r \times \R^r \to \R $の像について
	\[
	B(C_+ \times C_+), \,
	B(C_+ \times C_-), \,
	B(C_- \times C_-) \subset \R^\times
	\]
	が成り立つ. 
	今$ C_+, C_- $は連結なのでこれら$ 3 $つの集合も連結であり, 従って$ \R_{>0} $または$ \R_{<0} $の部分集合となる. 
	$ c_\pm := (0, \dots, 0, \pm 1) \in \R^r $に対し$ B(c_\pm, c_\pm) $を計算することにより
	\[
	B(C_+ \times C_+) \subset \R_{<0}, \quad
	B(C_+ \times C_-) \subset \R_{>0}, \quad
	B(C_- \times C_-) \subset \R_{<0}
	\]
	が従う. 
\end{proof}

この補題から, \cref{dfn:Zwegers_theta_special}における$ c_1, c_2 $は$ \{ c \in \R^r \mid Q(c) < 0 \} $の同じ連結成分に属していることが分かる. 
そこで連結成分を$ 1 $つ固定して始めから$ c_1, c_2 $をその元として取っても同じことになるが, 実際Zwegers~\cite{Zwegers_thesis}や\cite{BFOR}ではそのような記述の仕方をしている. 

また連結成分を$ 1 $つ固定することはベクトル$ c_0 \in \R^r $であって$ Q(c_0) < 0 $なるものを固定することと同値である.
実際そのような$ c_0 $に対し
\[
\{ c \in \R^r \mid Q(c) < 0, \, B(c, c_0) < 0 \}
\]
は$ \{ c \in \R^r \mid Q(c) < 0 \} $の連結成分を定めていることが\cref{lem:cone}から分かる. 

% --------------------------------------------------------------------------

\section{Vign\'{e}rasの結果との関係} \label{sec:Vigneras}

% --------------------------------------------------------------------------

Zwegers~\cite{Zwegers_thesis}は彼が発見した不定値テータ関数のモジュラー変換則をPoissonの和公式から直接証明しているが, 実はこのことは彼以前の結果であるVign\'{e}ras~\cite{Vigneras}の文脈から理解することもできる. 
Vign\'{e}rasは不定値テータ関数を扱う一般的な枠組みを与えており, それに乗るような不定値テータ関数を実際に構成してみせたのがZwegersというわけである. 

%そこで本節ではVign\'{e}ras~\cite{Vigneras}の結果の紹介とZwegersの不定値テータ関数との関係について紹介する. 

% --------------------------------------------------------------------------

%\subsection{Vign\'{e}rasの結果} \label{subsec:Vigneras_result}

% --------------------------------------------------------------------------

それではVign\'{e}ras~\cite{Vigneras}が与えた様々な種類のテータ関数を生み出す枠組みを紹介しよう. 
ここではChoie--Lim~\cite{Choie_Lim}および\cite{BFOR}による定式化を紹介する. 

\begin{thm}[{Vign\'{e}ras~\cite{Vigneras}, Choie--Lim~\cite[Theorem 3.1]{Choie_Lim}, \cite[Theorem 8.27]{BFOR}}]
	\label{thm:Vigneras}
	\leavevmode %強制的な改行
	\begin{itemize}
		\item 正整数$ r \in \Z_{>0} $,
		\item 格子$ L \subset \R^r $,
		\item 符号数$ (r-s, s) $の非退化二次形式$ Q \colon L \to \Z $,
		\item $ C^\infty $関数$ p \colon \R^r \to \bbC $であって任意の$ 0 \le m \le 2 $と$ 1 \le i \le j \le r $に対し
		\[
		p(x) e^{-2\pi Q(x)}, %\quad
		\frac{\partial}{\partial x_i} p(x) e^{-2\pi Q(x)}, %\quad
		\frac{\partial^2}{\partial x_i \partial x_j} p(x) e^{-2\pi Q(x)}, %\quad
		x^m p(x) e^{-2\pi Q(x)}
		\in L^2(\R^n) \cap L^1(\R^n)
		\]
		なるもの
	\end{itemize}
	に対し
	\begin{itemize}
		\item 二次形式$ Q $に付随する双線形対称形式$ B \colon \R^r \times \R^r \to \R, \, (x, y) \mapsto Q(x+y) - Q(x) - Q(y) $,
		\item 双対格子$ L' := \{ x \in \R^r \mid B(x, l) \in \Z \text{ for any } l \in L \} $,
		\item 双線形形式$ B $の表現行列$ A \in \GL_r(\R) $,
		\item Euler作用素
		\[
		\calE := \sum_{i=1}^{r} x_i \frac{\partial}{\partial x_i}
		\colon L^2(\R^r) \to L^2(\R^r),
		\]
		\item 二次形式$ Q $に付随するラプラシアン
		\[
		\Delta_Q := \sprod{ \frac{\partial}{\partial x}, A^{-1} \frac{\partial}{\partial x} }
		\colon L^2(\R^r) \to L^2(\R^r)
		\]
	\end{itemize}
	とおく. 
	ここである整数$ \lambda \in \Z $に対し関数$ p $は\textbf{Vign\'{e}rasの微分方程式}
	\[
	\left( \calE - \frac{\Delta_Q}{4\pi} \right) p = \lambda p
	\]
	を満たすと仮定する. 
	このとき
	\begin{itemize}
		\item ベクトル$ z = \tau \alpha + \beta \in \bbC^r $, $ \alpha, \beta \in \R^r $,
		\item ベクトル$ \mu \in L' $
	\end{itemize}
	に対しテータ関数
	\[
	\Theta_{A, \mu} (z; \tau)
	:=
	\Im(\tau)^{-\lambda/2}
	\sum_{n \in \mu + L} p\left( \sqrt{\Im(\tau)} \left( n + \alpha \right) \right)
	e^{2\pi\iu B(n, z)} q^{Q(n)}
	\]
	が\textbf{収束するなら}, このテータ関数はモジュラー変換則
	\begin{align}
		\Theta_{A, \mu} \left( z; \tau + 1 \right)
		&=
		e^{\pi\iu Q( \mu + A^{-1} A^* / 2)}
		\Theta_{A, \mu} \left( z; \tau \right),
		\\
		\Theta_{A, \mu} \left( \frac{z}{\tau}; -\frac{1}{\tau} \right)
		&=
		\frac{(-\iu)^{r/2 - s} \tau^{\lambda + r/2}}{\sqrt{\abs{L'/L}}}
		e^{\pi\iu Q(A^{-1} A^*)}
		\sum_{\nu \in L'/L} e^{-2\pi\iu B(\mu, \nu) + 2\pi\iu Q(z) / \tau } 
		\Theta_{A, \nu} (z; \tau)
	\end{align}
	を満たす. 
	ただしここで行列$ A $の$ (i, j) $成分を$ A_{i, j} $とおき, $ A^* := (A_{1, 1}, \dots, A_{r, r}) \in \R^r $とおいた. 
\end{thm}

この定理ではVign\'{e}rasの微分方程式を満たしテータ関数が収束するような急減少関数$ p $の存在を仮定している. 
そこでこの結果を応用するためにはそのような$ p $を実際に発見することが大変重要である.
しかしながら$ p $の具体的構成はVign\'{e}ras~\cite{Vigneras}の1976年の仕事から実に四半世紀もの間, Zwegersが発見するまでなされることはなかった.
実のところ, この定理の枠組みから述べるとZwegersが示したことはそのような$ p $が誤差関数$ \erf $から構成できるということである. 
%Zwegersの結果との関係の詳細は次項で述べることにする. 
実際, 誤差関数$ \erf(z) $が微分方程式
\[
\left( 2 z \frac{d}{dz} + \frac{d^2}{dz} \right) \erf(z) = 0
\]
を満たすことからZwegersの不定値テータ関数の定義（\cref{dfn:Zwegers_theta_special}）で現れた変数$ x \in \R^r $の特殊関数
\[
p(x) :=
\erf \left( \sqrt{\pi} \frac{B(c_1, x)}{\sqrt{-Q(c_1)}} \right) - \erf \left( \sqrt{\pi} \frac{B(c_2, x)}{\sqrt{-Q(c_2)}} \right)
\]
が$ \lambda = 0 $に関するVign\'{e}rasの微分方程式を満たすことが従う. 

\begin{rem}
	\cref{thm:Vigneras}における$ p(x) $について, \cite[Theorem 8.27]{BFOR}では「$ p(x) $が急減少関数である」という強い仮定が課されているが, 誤差関数$ \erf(x) $は急減少関数でないのでこの仮定を満たしていない.
	Zwegersの結果を系として得るには$ p(x) $に対しより弱い条件を課す必要がある（以上のことは都築正男先生にご指摘頂きました）.
	\cref{thm:Vigneras}ではより弱い条件を述べているChoie--Lim~\cite[Theorem 3.1]{Choie_Lim}の記述に従った.
\end{rem}

本項の締めくくりとして\cref{thm:Vigneras}の証明のアイデアを述べる. 

\begin{proof}[$ \cref{thm:Vigneras} $の証明のアイデア]
	一番目のモジュラー変換則は定義から従う. 
	二番目のモジュラー変換則を示すのが問題である. 
	
	古典的なテータ関数のモジュラー変換則はGauss関数がFourier変換で保たれることから従っており, それと同様にFourier変換で保たれる良い関数が見つかればモジュラー変換則を持つ新種のテータ関数が構成できるということを\cref{subsec:modular_completion}で述べた. 
	実はFourier変換で保たれる関数として古典的に知られているものがある. 
	それは\textbf{Hermite多項式}とGauss関数の積である. 
	これらの関数族は$ L^2(\R^r) $の完全直交系になることが知られているので, 急減少関数$ p(x) e^{-2\pi Q(x)} \in L^2(\R^r) $をこの完全直交系の線形和で書き下せる.
	すると$ p(x) e^{-2\pi Q(x)} \in L^2(\R^r) $のFourier変換を簡明に記述することができ, その結果$ p(x) e^{-2\pi Q(x)} $がFourier変換で保たれるような条件を記述することができる. 
	それがまさにVign\'{e}rasの微分方程式に相当するというわけである. 	
%	ここでHermite多項式$ H_n(x) $とは
%	\[
%	\sum_{n=0}^{\infty} H_n(x) \frac{t^n}{n!}
%	:=
%	e^{-2\pi (t^2 + 2xt)} 
%	\]
%	で定義され, 
	
	なお以上の議論では$ p(x) e^{-2\pi Q(x)} $をあくまで抽象的に完全直交系の線形和として扱っているため, $ p(x) $が明示的に（例えば何らかの特殊関数として）表されるかどうかについては全く何も述べていないことに注意する.
\end{proof}

% --------------------------------------------------------------------------

%\subsection{Zwegersの不定値テータ関数との関係} \label{subsec:Vigneras_Zwegers}

% --------------------------------------------------------------------------





% --------------------------------------------------------------------------

%\section{} \label{sec:}

% --------------------------------------------------------------------------



% --------------------------------------------------------------------------

%\subsection{} \label{subsec:}

% --------------------------------------------------------------------------



% --------------------------------------------------------------------------

\section*{謝辞}

% --------------------------------------------------------------------------

本稿は2022 年度八王子数論セミナー「モックテータ関数」での私の発表のために準備したものです. 
セミナーの運営に尽力して下さったセミナーオーガナイザーの松坂俊輝さん（九州大学）と, 世話人の安福悠先生（日本大学）に深く感謝いたします. 
また松坂さんには2020年に14回以上にわたる個人的なセミナーにて\ruby{擬}{モック}テータ関数やZwegersの不定値テータ関数, Vign\'{e}rasの結果や関連する研究について懇切丁寧に教えて頂きました. 
特に本稿の\cref{sec:Vigneras}の内容は松坂さんから個人的なセミナーにて教わった内容に基づくものです. 
当時そのように丁寧にお教え頂いてなかったら本稿を書くことは全く叶いませんでした. 
松坂さんには数学的な誤りや誤植についてもご指摘頂きました。
大変感謝いたします. 
小野雅隆さん（早稲田大学）には多くの誤植や言葉遣いをご指摘頂きました.
都築正男先生（上智大学）には\cref{sec:Vigneras}の内容について数学的な誤りと誤植をご指摘頂きました.
指導教員である山内卓也先生（東北大学）には本稿全体を通して数学的な誤りや言葉遣いについてご指摘頂きました.
ここに深く感謝いたします.

% --------------------------------------------------------------------------
%		参考文献
% --------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{indefinite_theta}
% 日本語の書籍タイトルがゴシック体になる. 見苦しいようなら\emphコマンドを書き換える. 

% --------------------------------------------------------------------------
\end{document}
% --------------------------------------------------------------------------